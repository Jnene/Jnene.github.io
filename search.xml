<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux账户管理、进程管理</title>
      <link href="2022/03/24/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2022/03/24/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux账户管理、进程管理"><a href="#Linux账户管理、进程管理" class="headerlink" title="Linux账户管理、进程管理"></a>Linux账户管理、进程管理</h1><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    Linux是多用户多任务操作系统，所以熟悉用户账户和进程的管理是十分有必要的。</p><h2 id="账户管理"><a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h2><h3 id="账户概述"><a href="#账户概述" class="headerlink" title="账户概述"></a>账户概述</h3><p>Linux中账户分为用户账户和组账户。</p><p>用户账户分为普通用户账户和管理员用户账户。用户账户可以在系统上进行日常工作，管理员账户用来管理账户和系统。管理员账户有系统操作的最高权限。即使系统有一个人在使用，在日常工作中建议使用普通用户账户登录，以此防止管理员账户操作不当损害系统。</p><p>组是用户的集合。组账户分为标准组和私有组。当创建一个用户时，不指定组账户默认创建和用户同名的私有组；如果想让用户加入标准组，应在创建用户时指定。</p><p>一个用户可以有多个组，当一个用户属于多个组时，登录后的组是主组，其它的组为附加组。</p><h3 id="账户系统文件"><a href="#账户系统文件" class="headerlink" title="账户系统文件"></a>账户系统文件</h3><ol><li><p><code>/etc/passwd</code>：存放账户信息</p><p><img src="1-1.jpg" class="lazyload" data-srcset="1-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>该文件中的字段以<code>:</code>分隔，字段含义从左到右依次为：用户名、用户口令(加密)、用户ID(UID，管理员账户UID为0，系统账户UID为1-499，普通用户UID为500及以后)、组ID(GID，用户登录以后的主组ID)、存放用户全名地理位置等信息、用户宿主目录、shell版本</li><li>该文件所有用户可读</li></ul></li><li><p><code>/etc/shadow</code>：存放账户口令信息</p><p><img src="1-2.jpg" class="lazyload" data-srcset="1-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>该文件root用户可读</li></ul></li><li><p><code>/etc/group</code>：存放组的信息</p><p><img src="1-3.jpg" class="lazyload" data-srcset="1-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>该文件字段含义从左到右依次为：组名、组口令(加密)、组标识(UID)、组成员(成员之间用逗号分隔)</li><li>该文件所有用户可读</li></ul></li><li><p><code>/etc/gshadow</code>：定义用户口令、组管理员等信息</p><p><img src="1-4.jpg" class="lazyload" data-srcset="1-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>该文件字段含义从左到右依次为：组名、组口令(加密)、组管理员、组成员(成员之间用逗号分隔)</li></ul></li></ol><h3 id="管理账户"><a href="#管理账户" class="headerlink" title="管理账户"></a>管理账户</h3><h4 id="管理用户账户"><a href="#管理用户账户" class="headerlink" title="管理用户账户"></a>管理用户账户</h4><ol><li><p>添加用户</p><p>语法：<code>useradd [&lt;参数&gt;] &lt;用户名&gt;</code></p><p>参数：</p><blockquote><p>-g：指定主组</p><p>-G：指定附加组</p><p>-u：指定用户id</p><p>-d：指定用户宿主目录，如果不存在，可以用-m参数创建</p></blockquote></li><li><p>修改用户</p><p>语法：<code>usermod [&lt;参数&gt;] &lt;用户名&gt;</code></p><p>参数：</p><blockquote><p>-l &lt;新用户名&gt;：修改用户名</p><p>其它参数和添加用户参数相同</p></blockquote></li><li><p>删除用户</p><p>语法：<code>userdel [-r] &lt;用户名&gt;</code></p><p><code>-r</code>表示删除用户的同时删除用户目录</p></li></ol><h4 id="管理组账户"><a href="#管理组账户" class="headerlink" title="管理组账户"></a>管理组账户</h4><ol><li><p>添加组账户</p><p>语法：<code>groupadd [&lt;参数&gt;] &lt;组名&gt;</code></p><p>参数：</p><blockquote><p>-g：指定组ID</p><p>-r：创建系统工作组，组id小于500</p></blockquote></li><li><p>修改组账户</p><p>语法：<code>groupadd [&lt;参数&gt;]</code></p><p>参数：</p><blockquote><p>-n &lt;组名&gt; &lt;用户名&gt;：将用户添加至指定组</p></blockquote></li><li><p>删除组账户</p><p>语法：<code>groupdel &lt;组名&gt;</code></p><p>通过查看<code>/etc/group</code>文件可以判断组是否删除成功</p></li></ol><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><p>语法：<code>passwd [&lt;参数&gt;] &lt;用户名&gt;</code></p><p>参数：</p><blockquote><p>-S：查看口令状态</p><p>-d：删除口令</p><p>-l：锁定口令，不允许用户修改</p><p>-u：解锁口令</p><p>-e：密码过期，强制用户下次登录修改密码</p></blockquote><blockquote><p>提示：root用户可以修改所有人的密码，普通用户只能修改自己的密码</p></blockquote><h4 id="设置密码时效"><a href="#设置密码时效" class="headerlink" title="设置密码时效"></a>设置密码时效</h4><p>为了保证系统安全，最好每隔一段时间就修改密码。密码时效规定了口令最长有效天数、口令修改的最短间隔时间、口令过期提前几天提醒等信息。</p><p>对于未来要创立的用户，设置密码时效通过修改<code>/etc/login.defs</code>文件</p><p><img src="2-1.jpg" class="lazyload" data-srcset="2-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>对于已经存在的账户，用<code>chage</code>命令来更改密码时效</p><p>语法：<code>chage [&lt;选项&gt;] &lt;用户名&gt;</code></p><p>选项：</p><blockquote><p>-M：口令最长有效天数</p><p>-W：口令过期提前几天提醒</p><p>-l：当前口令的详情信息</p></blockquote><h4 id="用户和组状态"><a href="#用户和组状态" class="headerlink" title="用户和组状态"></a>用户和组状态</h4><p>通过下列命令来查看当前用户和组信息</p><p><code>whoami</code>：当前登录用户</p><p><img src="3-1.jpg" class="lazyload" data-srcset="3-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>id</code>：用户信息和用户当前组信息</p><p><img src="3-2.jpg" class="lazyload" data-srcset="3-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>groups</code>：用户所在组</p><p><img src="3-3.jpg" class="lazyload" data-srcset="3-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>newgrp &lt;组名&gt;</code>：切换组</p><p><img src="3-4.jpg" class="lazyload" data-srcset="3-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML之用例图、类图、时序图</title>
      <link href="2022/03/23/UML%E4%B9%8B%E7%94%A8%E4%BE%8B%E5%9B%BE%E3%80%81%E7%B1%BB%E5%9B%BE%E3%80%81%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
      <url>2022/03/23/UML%E4%B9%8B%E7%94%A8%E4%BE%8B%E5%9B%BE%E3%80%81%E7%B1%BB%E5%9B%BE%E3%80%81%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="UML之用例图、类图、时序图"><a href="#UML之用例图、类图、时序图" class="headerlink" title="UML之用例图、类图、时序图"></a>UML之用例图、类图、时序图</h1><p>[toc]</p><h2 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML"></a>什么是UML</h2><p>统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。</p><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>用例图站在用户的角度展示系统的功能。主要展示2个信息：哪些用户使用系统和用户能够使用的系统功能</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li><p>用户</p><p>使用系统的角色。如超市管理系统的售货员、会员等。</p><p>用户在用例图中用一个小人表示</p><p><img src="2-1.jpg" class="lazyload" data-srcset="2-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用户"></p></li><li><p>用例</p><p>系统的具体功能。如图书管理系统的查询图书馆功能、添加图书功能等。</p><p>在用例图中用椭圆表示</p><p><img src="2-2.jpg" class="lazyload" data-srcset="2-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用例"></p></li><li><p>关系</p><p>用例图中的关系有关联、泛化、包含和扩展。</p><p>关联：表示用户和用例之间的关系。用实线标识。</p><p><img src="2-3.jpg" class="lazyload" data-srcset="2-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="关联"></p><p>泛化：类似面向对象的继承关系，可以用在用户和用户之间，也可以用在用例和用例之间。用空心箭头标识，箭头指向父类。</p><p><img src="2-4.jpg" class="lazyload" data-srcset="2-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用例与用例之间的泛化"></p><p><img src="2-5.jpg" class="lazyload" data-srcset="2-5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用户和用户之间的泛化"></p><p>包含：当用例特别复杂，可以将用例抽象成一个大的功能，再让该用例指向小功能的用例。用虚线箭头标识，箭头指向小功能的用例。</p><p><img src="2-6.jpg" class="lazyload" data-srcset="2-6.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="包含关系"></p><p>扩展：表示功能的拓展功能。用虚线箭头标识，箭头指向被拓展的用例。</p><p><img src="2-7.jpg" class="lazyload" data-srcset="2-7.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="扩展关系"></p></li></ol><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图描述了类的方法属性以及和其他类之间的关系</p><h3 id="类图的组成"><a href="#类图的组成" class="headerlink" title="类图的组成"></a>类图的组成</h3><p>一个类的类图由3个矩形组成，其中第一个矩形是类名，第二个矩形是类的属性，第三个矩形是类的方法。</p><p>比如定义一个Employee类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer empId; <span class="comment">//员工编号</span></span><br><span class="line">    <span class="keyword">private</span> String empName; <span class="comment">//员工姓名</span></span><br><span class="line">    <span class="keyword">private</span> Double empSalary; <span class="comment">//员工薪资</span></span><br><span class="line">    <span class="keyword">private</span> Integer empDeptId; <span class="comment">//员工部门编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getOffWork</span><span class="params">(Integer empId)</span></span>&#123; <span class="comment">//签到</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123; <span class="comment">//工作</span></span><br><span class="line">        </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的类图如图所示：</p><p><img src="3-1.jpg" class="lazyload" data-srcset="3-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="员工类图"></p><h3 id="类图包含的关系"><a href="#类图包含的关系" class="headerlink" title="类图包含的关系"></a>类图包含的关系</h3><ol><li><p>泛化</p><p>表示类的继承关系。用实线空心箭头标识，箭头指向父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brid</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="3-2.jpg" class="lazyload" data-srcset="3-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="泛化"></p></li><li><p>实现</p><p>表示接口和类的实现关系。用虚线空心箭头标识，箭头指向接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Brid</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">implements</span> <span class="title">Brid</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="3-3.jpg" class="lazyload" data-srcset="3-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="实现"></p></li><li><p>关联</p><p>表示类是另一个类的属性。用实线箭头标识，箭头指向属性类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    Driver driver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="3-4.jpg" class="lazyload" data-srcset="3-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="关联"></p></li><li><p>聚合</p><p>是特殊的关联关系，表示类是另一个类的属性，同时该属性类不止一个，即在类中用集合或数组定义。两个类之间是部分和整体的关系，但是两者的生命周期互不影响。用实线空心菱形标识，指向整体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span></span>&#123;</span><br><span class="line">    Student[] students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="3-5.jpg" class="lazyload" data-srcset="3-5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="聚合"></p></li><li><p>组合</p><p>是特殊的聚合关系。类和类之间也是部分与整体的关系，但是两者的生命周期相互影响。用实线实心菱形标识，指向整体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">Limbs[] limbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Limbs</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="3-6.jpg" class="lazyload" data-srcset="3-6.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="组合"></p></li><li><p>依赖</p><p>最弱的包含关系，标识一个类是另一个类的局部变量。用虚线箭头标识，指向局部变量类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="3-7.jpg" class="lazyload" data-srcset="3-7.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="依赖"></p></li></ol><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>时序图用来说明系统某个功能内部是如何实现的，类与类之间是如何调用的。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以管理员查看用户信息功能为例绘制时序图</p><p>功能界面：</p><p><img src="4-1.jpg" class="lazyload" data-srcset="4-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="查看用户信息用例时序图"></p><p>查看用户功能时序图：</p><p><img src="4-2.jpg" class="lazyload" data-srcset="4-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用户功能时序图"></p><p>改图有这样几个组成部分：</p><p>小人代表动作的发出者。矩形代表对象。绿色矩形代表一个方法。实线实心箭头代表一次请求，实线矩形实心箭头代表自调用。虚线箭头代表返回值。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fromtitle=UML&fromid=446747&fr=aladdin">统一建模语言</a></p><p><a href="bilibili.com/video/BV1L4411x76j?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">【动力节点】UML与Rational Rose__老杜</a></p><p><a href="https://www.cnblogs.com/lcword/p/10472040.html">UML建模——用例图（Use Case Diagram）</a></p><p><a href="https://www.cnblogs.com/bjut13062222/p/5433674.html">用Visio画UML用例图</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js闭包</title>
      <link href="2022/03/22/js%E9%97%AD%E5%8C%85/"/>
      <url>2022/03/22/js%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h1><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    做一个练手项目时有如图所示代码：</p><p><img src="1-1.png" class="lazyload" data-srcset="1-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>​    bug就在for循环为元素绑定单击事件的代码块中，这里for循环的i是从0-4，可是在单击事件绑定的匿名函数中i的值一直是5。</p><p>​    后来将绑定事件的代码放到一个函数里，将用到的参数传递给绑定事件的函数，问题就解决了</p><p><img src="1-2.png" class="lazyload" data-srcset="1-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>虽然问题解决了，但始终不明白为什么会这样，网上查阅资料发现是闭包的问题，下面就闭包写出我的看法</p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>​    在函数中定义函数，在函数中定义的函数就是闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在函数a中定义了函数b，函数b就是一个闭包。通过函数b能访问到在函数a中定义的局部变量。</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>通过闭包可以延长局部变量的生命周期。局部变量是在函数内部定义的变量，函数被调用，局部变量被创建，函数调用完成，局部变量被销毁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">num += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line">alert(a()); <span class="comment">// 0</span></span><br><span class="line">alert(a()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果函数返回一个闭包函数，在闭包函数中又返回了函数的一个局部变量，此时函数的返回值闭包函数赋值给一个变量，由于变量是全局变量，会在整个程序执行完毕后销毁，闭包函数也就随之存在，当然，闭包函数中调用的局部变量也会一直存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">num += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a();</span><br><span class="line">alert(b()); <span class="comment">// 1</span></span><br><span class="line">alert(b()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>此时在分析前言中遇到的问题就会明白，在for循环中定义的局部变量i并没有被销毁，值一直是5，每次单击事件都会访问i的值。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/pixabayhao/p/7239943.html">关于js for循环click事件 </a></p><p><a href="https://www.w3school.com.cn/js/js_function_closures.asp">JavaScript 闭包</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务概述</title>
      <link href="2022/03/22/mysql%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"/>
      <url>2022/03/22/mysql%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql事务概述"><a href="#mysql事务概述" class="headerlink" title="mysql事务概述"></a>mysql事务概述</h1><p>[toc]</p><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>​    事务在mysql中是一组DML语句的合集。</p><p>​    事务可以抽象成现实场景，比如从账户A向账户B转钱。首先要将A账户的钱减去，然后让账户B的钱增加。转账的操作就是一个事务。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>​    事务遵循ACID四大特性。</p><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h3><p>​    事务是最小的执行单位，事务中的DML语句要么都执行成功，如果有一个语句执行失败，事务就要回滚到初始状态。</p><h3 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h3><p>​    事务的执行结果要和现实业务逻辑相似，执行结果要符合预期。</p><h3 id="隔离性-Isoladon"><a href="#隔离性-Isoladon" class="headerlink" title="隔离性(Isoladon)"></a>隔离性(Isoladon)</h3><p>​    多个事务并发执行，事务之间互不影响和干扰。</p><h3 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h3><p>​    事务提交后数据应被保存到硬盘中。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>根据事务的隔离性，事务有4大隔离级别，隔离级别越高，事务并发执行的效率就越低。</p><h3 id="读未提交-READ-UNCOMMITED"><a href="#读未提交-READ-UNCOMMITED" class="headerlink" title="读未提交(READ UNCOMMITED)"></a>读未提交(READ UNCOMMITED)</h3><p>​    一个事务可以读取到另一个事务未提交的数据。读未提交会带来<strong>脏读</strong>问题。</p><p>​    脏读是指读取到的数据没有意义，事务未提交之前，表中的数据都是可能随时改变的。</p><h3 id="读已提交-READ-COMMITED"><a href="#读已提交-READ-COMMITED" class="headerlink" title="读已提交(READ COMMITED)"></a>读已提交(READ COMMITED)</h3><p>​    一个事务只能读取到另一个事务提交的数据。读已提交解决了脏读的问题，但又带来了<strong>不可重复读</strong>的问题。</p><p>​    不可重复读是指不能读取到某个时间点之前表中的数据，读已提交读到的数据都是真实的。</p><h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h3><p>​    当一个事务开启后，只能读到事务开启前的数据，其他事务对数据的修改无法读到。可重复读解决了不可重复读的问题，但又带了<strong>幻读</strong>的问题。</p><p>​    幻读是指从表中读取到的数据是不真实的，只能读到事务开启之前表中的数据，再此期间读取不到表中后来更新的数据。</p><p>​    幻读只是读取不到表中的数据，但是如果有另一个事务插入一条主键为“1001”的数据并提交，在本事务中又插入了一条主键为“1001”的数据，这是不允许的。</p><h3 id="串行-序列化-SERIALIZABLE"><a href="#串行-序列化-SERIALIZABLE" class="headerlink" title="串行/序列化(SERIALIZABLE)"></a>串行/序列化(SERIALIZABLE)</h3><p>​    最高的隔离级别，不允许多个事务同时对一张表进行操作。</p><p>​    串行/序列化隔离级别解决了脏读、不可重复读、幻读，但是多事务并发执行效率低。</p><h2 id="mysql中有关事务的操作"><a href="#mysql中有关事务的操作" class="headerlink" title="mysql中有关事务的操作"></a>mysql中有关事务的操作</h2><ol><li><p>开启事务：<code>start transaction;</code></p></li><li><p>开启只读事务：<code>start transaction read only</code></p><p>只读事务只能执行DQL语句，不能执行DML语句，在执行DDL语句之后事务自动提交结束。</p></li><li><p>提交事务：<code>commit;</code></p></li><li><p>事务回滚：<code>rollback;</code></p></li><li><p>设置事务保存点：<code>savepoint 【保存点名称】</code></p><p><code>rollback</code>语句只能回滚到事务开启前的状态，不能回滚到事务开启后某个语句执行之前的状态，用<code>savepoint</code>设置保存点后，就可以用<code>rollback to 【保存点名称】</code>回滚到事务开启后某个语句执行之前的状态。</p></li><li><p>查看事务隔离级别：<code>select @@tx_isolation;</code></p></li><li><p>设置事务隔离级别</p><p>设置会话级隔离级别：<code>set transaction isolation level【隔离级别】</code></p><p>设置全局隔离级别：<code>set global transaction isolation level【隔离级别】</code></p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/ryelqy/p/11434120.html">mysql事务隔离级别与设置</a><br><a href="https://www.aliyundrive.com/s/b3gRaZTVyJP">mysql笔记 第14篇事务讲解</a><br><a href="https://www.nowcoder.com/tutorial/94/1f2614a674cf4854b01166df67fd7366">【Java工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网</a><br><a href="https://www.bilibili.com/video/BV1Vy4y1z7EX?p=110">老杜带你学_mysql入门基础（mysql基础视频+数据库实战)_哔哩哔哩_bilibili p102-p112</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax同步和异步的选择</title>
      <link href="2022/03/21/ajax%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>2022/03/21/ajax%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="ajax同步和异步的选择"><a href="#ajax同步和异步的选择" class="headerlink" title="ajax同步和异步的选择"></a>ajax同步和异步的选择</h1><p>[toc]</p><h2 id="ajax简单介绍"><a href="#ajax简单介绍" class="headerlink" title="ajax简单介绍"></a>ajax简单介绍</h2><p>​    使用ajax技术可以让我们不用刷新网页就可以向服务器获取需要的数据并用js把他显示在页面。ajax的核心是XMLHttpRequest对象(后文简称xhr对象)，使用xhr对象就可以和服务器交换数据。</p><p>​    xhr对象的open()方法可以帮助我们和服务器建立连接，open()方法需要我们传入<code>open(method, url, async)</code>三个参数，其中<code>async</code>参数规定了ajax是异步还是同步，<code>async</code>的默认值为<strong>true</strong>，也就是说我们如果省略<code>async</code>参数的话默认就是异步ajax。</p><p>​    异步指的是当ajax请求发出后，js不用等待xhr回调函数的执行完毕，继续执行后续代码；如果是同步ajax则js需要等xhr的回调函数执行完毕后执行后续代码。</p><h2 id="ajax的一个错误使用场景"><a href="#ajax的一个错误使用场景" class="headerlink" title="ajax的一个错误使用场景"></a>ajax的一个错误使用场景</h2><p><img src="2-1.jpg" class="lazyload" data-srcset="2-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>假设我们有图示的修改用户信息的模态框，实现这个模态框页面的逻辑如下：</p><ol><li>ajax向服务器获取部门信息(这是因为部门信息在实际业务逻辑中可能会发生改变，需要动态获取)</li><li>显示模态框，将获取的部门信息填充到下拉列表</li><li>ajax向服务器获取要修改的用户信息</li><li>将用户信息填充到模态框表单中</li></ol><p>对应的伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.ajax向服务器获取部门信息(这是因为部门信息在实际业务逻辑中可能会发生改变，需要动态获取)</span></span><br><span class="line"><span class="keyword">var</span> xhr1 = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr1.open(method, url, <span class="literal">true</span>);</span><br><span class="line">xhr1.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//2.显示模态框，将获取的部门信息填充到下拉列表</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">xhr1.send();</span><br><span class="line"><span class="comment">//3.ajax向服务器获取要修改的用户信息</span></span><br><span class="line"><span class="keyword">var</span> xhr2 = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr2.open(method, url, <span class="literal">true</span>);</span><br><span class="line">xhr2.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//4.将用户信息填充到模态框表单中</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">xhr2.send();</span><br></pre></td></tr></table></figure><p>​    根据上述代码，xhr1对象为异步ajax。假设代码进行到第四步，我们的模态框还没渲染好，那么向模态框中填充数据就会出问题。合理的逻辑应该是模态框渲染完毕之后我们在进行后续操作，所以xhr1对象应该建立为同步ajax。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    异步ajax虽然保证了代码执行的效率，但是也要根据业务逻辑的前后关系来设计代码，不要盲目使用ajax</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis运行过程源码分析</title>
      <link href="2022/03/17/mybatis%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>2022/03/17/mybatis%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis运行过程源码分析"><a href="#mybatis运行过程源码分析" class="headerlink" title="mybatis运行过程源码分析"></a>mybatis运行过程源码分析</h1><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    了解mybatis运行流程是mybatis插件开发的前提，下面根据mybtais最基本的流程来分析mybatis运行过程</p><p>mybatis版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">/*1.通过SqlSessionFactoryBuilder获取SqlSessionFactory对象*/</span></span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        <span class="comment">/*2.获取SqlSession对象*/</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">/*3.获取接口的实现对象(MapperProxy)*/</span></span><br><span class="line">        EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">        <span class="comment">/*4.执行增删改查*/</span></span><br><span class="line">        Emp emp = empMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="1-创建SqlSessionFactory对象"><a href="#1-创建SqlSessionFactory对象" class="headerlink" title="1.创建SqlSessionFactory对象"></a>1.创建SqlSessionFactory对象</h3><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><ol><li><p>创建SqlSessionFactoryBuilder对象，调用build方法传入InputStream参数</p><p><img src="1-1.jpg" class="lazyload" data-srcset="1-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>步入build方法</p><p><img src="1-2.jpg" class="lazyload" data-srcset="1-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>调用SqlSessionFactoryBuilder对象中build的重载方法，继续步入该方法</p><p><img src="1-3.jpg" class="lazyload" data-srcset="1-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法定义了一个SqlSessionFactory接口并初始化后返回，我们重点关注SqlSessionFactory接口的初始化过程，注意，我们在第一步中创建的InputStream不需要我们手动调用它的close方法，这是因为在build方法中该I/O流已经被关闭</p></li></ol><h4 id="build方法中SqlSessionFactory接口的初始化流程"><a href="#build方法中SqlSessionFactory接口的初始化流程" class="headerlink" title="build方法中SqlSessionFactory接口的初始化流程"></a>build方法中SqlSessionFactory接口的初始化流程</h4><p>我们看try-catch语句块，首先定义了XMLConfigBuilder的示例parser，该对象的作用是创建一个Configuration对象，该对象中定义了xml配置文件的相关信息。</p><p>重点关注SqlSessionFactory的对象是如何创建的，首先调用SqlSessionFactoryBuilder对象的build的另一个重载方法，并用parser对象的parse方法创建一个Configuration对象作为参数传入，我们先看parse方法创建Configuration对象的流程再看build方法的执行流程</p><h5 id="parse方法创建Configuration对象的流程"><a href="#parse方法创建Configuration对象的流程" class="headerlink" title="parse方法创建Configuration对象的流程"></a>parse方法创建Configuration对象的流程</h5><p>步入该方法</p><p><img src="1-6.jpg" class="lazyload" data-srcset="1-6.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>this.parsed的初始值是false，这保证Configuration对象不会被重复创建</p><p>接着步入parseConfiguration方法</p><p><img src="1-7.jpg" class="lazyload" data-srcset="1-7.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法主要是用来解析mybatis的xml配置文件，该方法的参数为mybatis-config.xml的根节点configuration</p><p>以<code>this.propertiesElement(root.evalNode(&quot;properties&quot;));</code>为例，该语句的作用就是解析mybatis-config.xml文件中配置的properties标签中的内容，具体执行流程如下图：</p><p><img src="1-8.jpg" class="lazyload" data-srcset="1-8.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>由于都是xml解析相关的内容，这里不详细分析</p><h5 id="build方法的执行流程"><a href="#build方法的执行流程" class="headerlink" title="build方法的执行流程"></a>build方法的执行流程</h5><p>步入该方法</p><p><img src="1-4.jpg" class="lazyload" data-srcset="1-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法新建了一个DefaultSqlSessionFactory对象，这说明我们创建的SqlSessionFactory对象是一个DefaultSqlSessionFactory对象。继续步入DefaultSqlSessionFactory对象的构造方法</p><p><img src="1-5.jpg" class="lazyload" data-srcset="1-5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该构造方法将传入的Configuration对象赋值给了DefaultSqlSessionFactory对象的属性。</p><p>至此，SqlSessionFactory创建完成</p><h3 id="2-获取SqlSession对象"><a href="#2-获取SqlSession对象" class="headerlink" title="2.获取SqlSession对象"></a>2.获取SqlSession对象</h3><p>步入openSession()方法</p><p><img src="2-1.jpg" class="lazyload" data-srcset="2-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>步入openSessionFromDataSource方法</p><p><img src="2-2.jpg" class="lazyload" data-srcset="2-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>前面几句是关于环境和事务的设置，这里重点关注<code>Executor executor = this.configuration.newExecutor(tx, execType);</code>，该语句创造了一个执行器对象，该对象主要用来执行sql语句。</p><p>步入newExecutor方法</p><p><img src="2-3.jpg" class="lazyload" data-srcset="2-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法首先根据executor的不同类型创建不同的executor对象，关于executor的类型mybatis官方文档中有说明，该属性被配置在mybatis-config.xml的setting标签中。</p><p><img src="2-4.jpg" class="lazyload" data-srcset="2-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后判断我们是否开启了二级缓存，如果开启，就用CachingExecutor包装我们刚刚创建的executor对象。</p><p>注意最后executor对象又被<code>Executor executor = (Executor)this.interceptorChain.pluginAll(executor);</code>语句包装，改包装过程涉及到插件的知识，这里不详细说明</p><p>至此我们回到刚刚的openSessionFromDataSource方法，<code>var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);</code>该语句将configuration和executor对象封装至SqlSession对象，至此，SqlSession对象获取完成</p><h3 id="3-获取接口的实现对象"><a href="#3-获取接口的实现对象" class="headerlink" title="3.获取接口的实现对象"></a>3.获取接口的实现对象</h3><p>步入sqlSession.getMapper()方法</p><p><img src="3-1.jpg" class="lazyload" data-srcset="3-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>继续步入this.configuration.getMapper(type, this)方法</p><p><img src="3-2.jpg" class="lazyload" data-srcset="3-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>继续步入this.mapperRegistry.getMapper(type, sqlSession)方法</p><p><img src="3-3.jpg" class="lazyload" data-srcset="3-3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法声明了MapperProxyFactory对象，并用该对象去创建MapperProxy对象，步入创建MapperProxy对象的过程方法<code>return mapperProxyFactory.newInstance(sqlSession);</code></p><p><img src="3-4.jpg" class="lazyload" data-srcset="3-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法首先创建了一个MapperProxy对象，注意，该对象实现了InvocationHandler接口</p><p>步入this.newInstance(mapperProxy)方法</p><p><img src="3-5.jpg" class="lazyload" data-srcset="3-5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>该方法创建了我们传入接口的代理，使用的方式是JDK动态代理。</p><p>至此，接口的实现对象创建完成</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/jiankunking/article/details/52143504">JDK动态代理</a></p><p><a href="https://www.bilibili.com/video/BV1mW411M737?p=79&spm_id_from=pageDriver">尚硅谷MyBatis实战教程全套完整版 p71-p78</a></p><p><a href="https://www.aliyundrive.com/s/Ehv9FmDa9dh">深入浅出MyBatis技术原理与实战  第六章 MyBatis的解析和运行原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis高效获取SqlSession</title>
      <link href="2022/03/16/mybatis%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96SqlSession/"/>
      <url>2022/03/16/mybatis%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96SqlSession/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis高效获取SqlSession"><a href="#mybatis高效获取SqlSession" class="headerlink" title="mybatis高效获取SqlSession"></a>mybatis高效获取SqlSession</h1><p>[toc]</p><h2 id="SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession的作用域和生命周期"><a href="#SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession的作用域和生命周期" class="headerlink" title="SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession的作用域和生命周期"></a>SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession的作用域和生命周期</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>主要用来创建SqlSessionFactory实例，在创建完SqlSessionFactory实例之后不再使用。</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory用于创建SqlSession对象。在项目中通常需要频繁创建SqlSession对象，这是因为SqlSession对象在使用后应立刻关闭。所以SqlSessionFactory应该作用于整个项目且只创建一个实例。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>用于执行增删改查操作或创建接口映射对象，在使用后应立即关闭。所以SqlSession的实例应该只在方法中被创建。另外，SqlSession<strong>是非线程安全</strong>的，在多线程环境中应考虑线程安全问题</p><h2 id="SqlSessionFactoryUtil类的设计"><a href="#SqlSessionFactoryUtil类的设计" class="headerlink" title="SqlSessionFactoryUtil类的设计"></a>SqlSessionFactoryUtil类的设计</h2><p>结合综上所述，采用单例模式中的双重校验机制来设计代码</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SqlSessionFactoryUtils</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSessionFactory == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SqlSessionFactoryUtils.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sqlSessionFactory == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">mybatis作用域和生命周期</a></p><p><a href="https://jnene.github.io/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式——单例模式</a></p><p><a href="https://jnene.github.io/2022/03/15/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">多并发线程安全</a></p><p><a href="https://www.aliyundrive.com/s/Ehv9FmDa9dh">深入浅出MyBatis技术原理与实战  第二章 2.4部分</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——单例模式</title>
      <link href="2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式——单例模式"><a href="#设计模式——单例模式" class="headerlink" title="设计模式——单例模式"></a>设计模式——单例模式</h1><p>[toc]</p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>面向对象思想的一种设计方式。适用于创建一个全局可访问的唯一的实例对象</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>I/O和数据库的连接操作</li><li>WEB中的计数器，不用每次刷新就更新数据库，而是先缓存起来</li></ul><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><ul><li>类不能被实例化(构造方法私有)</li><li>提供唯一的实例化对象</li><li>全局可获取实例化对象</li></ul><h3 id="懒汉式–线程不安全"><a href="#懒汉式–线程不安全" class="headerlink" title="懒汉式–线程不安全"></a>懒汉式–线程不安全</h3><p><strong>特点</strong></p><ul><li>lazy加载，节省内存资源</li><li>线程不安全</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式–线程安全"><a href="#懒汉式–线程安全" class="headerlink" title="懒汉式–线程安全"></a>懒汉式–线程安全</h3><p><strong>特点</strong></p><ul><li>lazy加载</li><li>线程安全但getInstance()效率低</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>特点</strong></p><ul><li>非lazy加载，内存资源容易浪费</li><li>线程安全</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过loadclasser机制加载实例，不能确定是第一次使用时加载还是其它类调用加载</p><h3 id="双重校验锁（DCL–Double-Check-Locked）"><a href="#双重校验锁（DCL–Double-Check-Locked）" class="headerlink" title="双重校验锁（DCL–Double Check Locked）"></a>双重校验锁（DCL–Double Check Locked）</h3><p><strong>特点</strong></p><ul><li>lazy加载</li><li>线程安全</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<strong>懒汉式–非线程安全</strong>方式相比，<strong>DCL</strong>机制缩小了同步代码范围，当instance被创建好后，就不会出现线程安全问题，多线程可以异步执行</p><h3 id="内部静态类"><a href="#内部静态类" class="headerlink" title="内部静态类"></a>内部静态类</h3><p><strong>特点</strong></p><ul><li>lazy加载</li><li>线程安全</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inclass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<strong>饿汉式</strong>相比，该方式利用内部静态类的加载机制，只有调用<strong>getInstance()方法</strong>时，内部静态类被加载，才会创建<strong>INSTANCE</strong>对象，达到延迟加载的效果。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">菜鸟教程——单例模式</a></p><p><a href="https://www.cnblogs.com/paul011/p/8574650.html">静态内部类加载机制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——Java</title>
      <link href="2022/03/15/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>2022/03/15/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全——Java"><a href="#线程安全——Java" class="headerlink" title="线程安全——Java"></a>线程安全——Java</h1><p>[toc]</p><h2 id="导致线程安全问题的原因"><a href="#导致线程安全问题的原因" class="headerlink" title="导致线程安全问题的原因"></a>导致线程安全问题的原因</h2><ol><li>线程之间共享变量</li><li>线程对共享变量修改</li></ol><h2 id="如何解决线程安全问题"><a href="#如何解决线程安全问题" class="headerlink" title="如何解决线程安全问题"></a>如何解决线程安全问题</h2><p>保证并发的原子性、可见性、顺序性</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>​    保证一个操作要么都执行，要么都不执行。以取款为例，假设我们取款分为2步，第一步取钱，第二部更新余额。如果完成第一步之后出现异常导致第二步没有执行，就会出现问题。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>​    保证变量的值被修改后能够立即获取变量被修改后的值。在内存模型中，CPU直接操作缓存，再将操作后的结果更新到内存。如果缓存中的内容没有被更新到内存，内存中的内容又被其它线程获取，就会导致可见性问题。</p><h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>​    保证多线程并发下指令能够顺序执行。CPU为了执行效率会对指令进行重排列，即代码不一定是按顺序执行。在单线程中，虽然会重排列指令，但因为有变量之间的依赖关系所以即使指令重排列，最后的结果仍然是正确的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1; &#x2F;&#x2F;指令1</span><br><span class="line">int j &#x3D; 2; &#x2F;&#x2F;指令2</span><br><span class="line">i &#x3D; j + 1; &#x2F;&#x2F;指令3</span><br><span class="line">j &#x3D; i + 1; &#x2F;&#x2F;指令4</span><br></pre></td></tr></table></figure><p>上面代码的执行顺序可能是<code>指令1--&gt;指令2--&gt;指令3--&gt;指令4</code>，也有可能是<code>指令2--&gt;指令1--&gt;指令3--&gt;指令4</code>。指令3一定会在指令2之后执行，指令4一定会在指令3执行之后执行</p><p>在多线程环境中，失去的指令之间的依赖关系，就可能导致程序出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();   &#x2F;&#x2F;语句1</span><br><span class="line">inited &#x3D; true;             &#x2F;&#x2F;语句2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>在线程1中，语句2和语句1没有依赖关系，就可能导致语句2执行，接着如果不执行语句1而顺序执行线程2中的代码，就会导致context没有被初始化而报错</p><h2 id="java解决线程安全问题"><a href="#java解决线程安全问题" class="headerlink" title="java解决线程安全问题"></a>java解决线程安全问题</h2><p>使用<code>synchronized</code>对线程进行同步。</p><h3 id="synchronized保证原子性、可见性、顺序性"><a href="#synchronized保证原子性、可见性、顺序性" class="headerlink" title="synchronized保证原子性、可见性、顺序性"></a>synchronized保证原子性、可见性、顺序性</h3><p><code>synchronized</code>的作用是给可能出现线程安全问题的代码块加上锁，当有线程执行该代码块时，就会先看看有没有其它进程在执行该代码块，如果有的话就等待进程执行完毕在执行代码块；如果没有的话就执行代码块，并加上锁防止其它进程在本进程执行过程中执行。</p><p>由于线程之间排队执行代码，代码实在调用完毕之后被其它线程调用的，所以<code>synchronized</code>解决了线程安全问题，保证了多线程并发下的原子性、可见性和顺序性</p><h3 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h3><h4 id="synchronized作用于代码块"><a href="#synchronized作用于代码块" class="headerlink" title="synchronized作用于代码块"></a>synchronized作用于代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    <span class="keyword">synchronized</span>(共享变量)&#123;</span><br><span class="line"><span class="comment">//代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在执行同步代码前，先看共享变量是否被占用，如果占用就等待。优势在于同步范围可控，执行效率高</p><h4 id="synchronized作用于实例方法—对象锁"><a href="#synchronized作用于实例方法—对象锁" class="headerlink" title="synchronized作用于实例方法—对象锁"></a>synchronized作用于实例方法—对象锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于下面写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在执行方法前，先看该方法的对象是否被占用，如果占用就等待。优势在于方便，适用于同步整个方法</p><h4 id="synchronized作用于静态方法—类锁"><a href="#synchronized作用于静态方法—类锁" class="headerlink" title="synchronized作用于静态方法—类锁"></a>synchronized作用于静态方法—类锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在执行方法前，先看该方法所属类的实例是否被占用，如果占用就等待</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/guanghe/p/9206635.html">内存模型相关概念</a></p><p><a href="https://www.bilibili.com/video/BV1Rx411876f?p=780">老杜java线程安全部分 p780-p796</a></p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程</title>
      <link href="2021/09/26/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2021/09/26/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java网络编程"><a href="#java网络编程" class="headerlink" title="java网络编程"></a>java网络编程</h1><p>[toc]</p><h2 id="计算机网络基本概念概述"><a href="#计算机网络基本概念概述" class="headerlink" title="计算机网络基本概念概述"></a>计算机网络基本概念概述</h2><h3 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h3><p>计算机网络就是将在不同地方的多台计算机连接起来，实现资源的传输、共享。</p><h3 id="计算机网络三要素"><a href="#计算机网络三要素" class="headerlink" title="计算机网络三要素"></a>计算机网络三要素</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>若计算机之间想要通讯，就必须遵循相同的协议。网络体系结构分为7层：<em>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</em>,，实际应用中一般分为5层(7层太过理想化，难以实现)：应用层、传输层、网络层、数据链路层、物理层。</p><blockquote><p>应用层：负责将数据转换为二进制</p><p>传输层：负责将二进制封装成报文</p><p>网络层：负责报文分组</p><p>数据链路层：负责数字信号到电路信号的映射</p><p>物理层：发送数据</p></blockquote><p>每一层都有协议来完成一些功能。比如应用层协议有：HTTP(超文本传输协议)、FTP(文件传输协议)、SMTP(邮件协议)；传输层协议有：TCP、UDP；网络层协议：IP。</p><h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5><p>UDP是面向无连接的不可靠协议。数据传输过程中可能会造成数据丢失。常用来发送一些不重要的数据，比如视频等。</p><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>TCP是面向连接的可靠协议，数据传输安全但相较于UDP协议来说传输效率慢。面向连接是指如果两台计算机进行通信，必须要3次握手。</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>网络中用来标识一台主机。</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>用来标识一台主机上的进程。每一个进程的端口号都不能相同。</p><p>端口号有两个字节组成，数据范围从0到65535，其中1024之前的端口号用户不能自己分配使用，由计算机系统来分配使用。</p><blockquote><p>一些常用的端口号：</p><ul><li>http协议：80</li><li>mysql：3306</li><li>tomcat：8080</li></ul><p>注：这些只是默认端口号，端口号可以任意指定，只要不重复即可</p></blockquote><blockquote><p>windows中进程相关的代码</p><p>netstat -ano：查询所有进程信息</p><p>netstat -ano | findstr “端口号”：查询指定端口号进程</p><p>taskkill -f -pid 进程号：杀死指定进程</p></blockquote><p>不同协议的端口号可以相同，比如一个UDP进程的端口号为1028，则TCP进程的端口号也可以为1028。</p><h2 id="java实现网络编程"><a href="#java实现网络编程" class="headerlink" title="java实现网络编程"></a>java实现网络编程</h2><p>java网络编程相关类都被封装到【java.net.*】包下。实现网络编程的两个重要的类就是【java.net.Socket】和【java.net.ServerSocket】，使用Socket类我们就可以进行两台计算机之间的通信和数据共享。</p><p>Socket通过IO流来传输共享信息。</p><p>两个类都有IO异常，需要在编译前处理</p><h3 id="java-net-Socket"><a href="#java-net-Socket" class="headerlink" title="java.net.Socket"></a>java.net.Socket</h3><p>Socket类布置在客户端，实现客户端的套接字(套接字就是两台计算机之间通信的端点，它包括IP地址和端口号)。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>Socket(InetAddress address, int port)：连接指定的服务器</p></blockquote><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote><p>public InputStream getInputStream() throws IOException：获取网络输入流。用于接受服务器返回的数据。</p><p>public OutputStream getOutputStream() throws IOException：获取网络输出流。用于向服务器发送数据。</p><p>public void close() throws IOException：用于关闭套接字连接。</p></blockquote><h3 id="java-net-ServerSocket"><a href="#java-net-ServerSocket" class="headerlink" title="java.net.ServerSocket"></a>java.net.ServerSocket</h3><p>ServerSocket类布置在服务器端，实现服务器端的套接字</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>public ServerSocket(int port) throws IOException：实现服务器端的套接字，指定服务区端口号为port</p></blockquote><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote><p>public Socket accept() throws IOException：获取连接服务器的套接字。服务器通过改对象获取的Socket对象来接受和向客户端发送数据。</p><p>public void shutdownOutput() throws IOException：关闭客户端的输出流，并在流的末尾加上结束标记，之前发送的数据正常发送。</p></blockquote><p>下面用个小例子来熟悉这些基本方法的使用</p><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建服务器套接字，端口号为：1028</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">1028</span>);</span><br><span class="line"><span class="comment">//2.接受客户端套接字</span></span><br><span class="line">Socket socket = server.accept();</span><br><span class="line"><span class="comment">//3.用IO流接受客户端的数据</span></span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] infos = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">is.read(infos);</span><br><span class="line">System.out.println(<span class="string">&quot;客户端信息：&quot;</span> + <span class="keyword">new</span> String(infos));</span><br><span class="line"><span class="comment">//4.用IO流向客户端发送数据</span></span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">os.write(<span class="string">&quot;收到信息&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"><span class="comment">//5.关闭套接字</span></span><br><span class="line">server.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建客户端套接字，服务器为 127.0.0.1:1028</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1028</span>);</span><br><span class="line"><span class="comment">//2.获取客户端输出流，向服务器发送数据</span></span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">os.write(<span class="string">&quot;你好服务器&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"><span class="comment">//3.获取客户端输入流，接受服务器端的数据</span></span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] infos = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">is.read(infos);</span><br><span class="line">System.out.println(<span class="string">&quot;服务器消息：&quot;</span> + <span class="keyword">new</span> String(infos));</span><br><span class="line"><span class="comment">//4.关闭套接字连接</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>写完代码后，我们需要先开启服务器，在运行客户端代码。</p><p>服务器输出：【客户端信息：你好服务器】                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p><p>客户端输出：【服务器消息：收到信息】</p><p>需要注意的是，ServerSocket对象没有getInputStream()方法和getOutputStream()方法，我们需要用Socket对象的IO流对象来和客户端进行交互。</p><p>但是上述代码有个问题，服务器端只能接受一个客户端的消息，我们可以把上面的2-5步写到死循环里，这样只要我们不关闭服务器，服务器就会一直接受客户端的消息</p><p>服务器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建服务器套接字，端口号为：1028</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">1028</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.接受客户端套接字</span></span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    <span class="comment">//3.用IO流接受客户端的数据</span></span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] infos = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    is.read(infos);</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端信息：&quot;</span> + <span class="keyword">new</span> String(infos));</span><br><span class="line">    <span class="comment">//4.用IO流向客户端发送数据</span></span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;收到信息&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="comment">//5.关闭套接字</span></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//server.close();</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，这里我们不需要在代码中写关闭服务器套接字的代码</p></blockquote><p>经过改进后，我们的服务器已经可以处理多个客户端的信息，但是当客户端请求太多时，服务器可能处理压力大，这时候我们可以使用多线程来处理这个问题。</p><p>服务器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建服务器套接字，端口号为：1028</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">1076</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.接受客户端套接字</span></span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//3.用IO流接受客户端的数据</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] infos = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            is.read(infos);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端信息：&quot;</span> + <span class="keyword">new</span> String(infos));</span><br><span class="line">            <span class="comment">//4.用IO流向客户端发送数据</span></span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;收到信息&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="comment">//5.关闭套接字</span></span><br><span class="line">            socket.close();</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//server.close();</span></span><br></pre></td></tr></table></figure><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p>UDP通信的实现依靠【java.net.DatagramSocket】类来实现。</p><h4 id="java-net-DatagramSocket"><a href="#java-net-DatagramSocket" class="headerlink" title="java.net.DatagramSocket"></a>java.net.DatagramSocket</h4><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><blockquote><p>public DatagramSocket() throws SocketException：建立套接字对象，端口号由操作系统随机分配(一般用于客户端建立对象)</p><p>public DatagramSocket(int port) throws SocketException：建立套接字对象并指定端口号(一般用于服务器端建立对象)</p></blockquote><h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h5><blockquote><p>public void connect(InetAddress address, int port)：记录服务器的IP地址和端口号，一般由客户端指定</p><p>public void disconnect()：清楚记录的服务器IP地址和端口号，一般由客户端指定</p><p>public void receive(DatagramPacket p) throws IOException：指定DatagramPacket对象接受数据</p><p>public void send(DatagramPacket p) throws IOException：发送DatagramPacket对象中的数据</p><p>public void close()：关闭套接字连接</p></blockquote><h4 id="java-net-DatagramPacket"><a href="#java-net-DatagramPacket" class="headerlink" title="java.net.DatagramPacket"></a>java.net.DatagramPacket</h4><p>DatagramSocket主要是客户端和服务器端的连接，DatagramPacket主要负责存储连接过程中产生的数据</p><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5><blockquote><p>public DatagramPacket(byte[] buf,int length)：构造一个DatagramPacket用于接收长度的数据包length 。<br>length参数必须小于或等于buf.length 。</p></blockquote><h5 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h5><blockquote><p>public byte[] getData()：获取对象中存储的数据</p><p>public void setData(byte[] buf)：设置缓冲区中的数据</p></blockquote><p>一个UDP通信的简单例子</p><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建服务器端套接字，端口1028</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">1028</span>);</span><br><span class="line"><span class="comment">//2.创建DatagramPacket对象来存储传输数据</span></span><br><span class="line"><span class="keyword">byte</span>[] infos = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(infos,infos.length);</span><br><span class="line"><span class="comment">//3.接受数据</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line"><span class="comment">//4.获取dp中的数据</span></span><br><span class="line">String info = <span class="keyword">new</span> String(dp.getData());</span><br><span class="line">System.out.println(info);</span><br><span class="line"><span class="comment">//5.设置返回信息</span></span><br><span class="line">dp.setData(<span class="string">&quot;你好客户端&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"><span class="comment">//6.发送返回信息</span></span><br><span class="line">ds.send(dp);</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.建立客户端套接字</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//2.建立连接</span></span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">1028</span>);</span><br><span class="line"><span class="comment">//3.存储要发送的信息</span></span><br><span class="line"><span class="keyword">byte</span>[] infos = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(infos, infos.length);</span><br><span class="line">dp.setData(<span class="string">&quot;你好服务器&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">ds.send(dp);</span><br><span class="line"><span class="comment">//4.获取服务器返回的信息</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line">String info = <span class="keyword">new</span> String(dp.getData());</span><br><span class="line">System.out.println(info);</span><br></pre></td></tr></table></figure><p>服务器端代码优化可以参考TCP通信代码示例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="2021/09/18/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>2021/09/18/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><p>[toc]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过反射机制可以操作class文件。 </p><p>反射机制的主要类包：java.lang.reflect.*</p><p>主要类</p><p>java.lang.Class：代表字节码文件</p><p>java.lang.reflect.Methon：代表字节码文件中的方法</p><p>java.lang.reflect.Filed：代表字节码文件中的属性（成员属性和类属性）</p><p>java.lang.reflect.Constructor：代表字节码文件中的方法（成员方法和类方法）</p><h2 id="获取Class类的三种方式"><a href="#获取Class类的三种方式" class="headerlink" title="获取Class类的三种方式"></a>获取Class类的三种方式</h2><ol><li><em>Class.forName(String className)</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cls1 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(cls1); <span class="comment">// class java.lang.String</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>forName()是Class类的一个静态方法</li><li>参数为一个完整的类名(java.lang不能省略)</li></ol></blockquote><ol start="2"><li>class属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cls3 = <span class="keyword">int</span>.class;</span><br><span class="line">Class cls4 = String.class;</span><br><span class="line">System.out.println(cls3);<span class="comment">// int</span></span><br><span class="line">System.out.println(cls4);<span class="comment">// class java.lang.String</span></span><br></pre></td></tr></table></figure><blockquote><p>Java中的任何一种类型(基本数据类型和引用数据类型)都有class属性。</p></blockquote><ol start="3"><li><em>getClass()</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls2 = String.class;</span><br><span class="line">System.out.println(cls2);<span class="comment">// class java.lang.String</span></span><br></pre></td></tr></table></figure><blockquote><p>Object 类中有一个getClass()方法，用于获得类的字节码文件。因此，所有类都可以通过这个方法获得类对应的字节码文件</p></blockquote><h3 id="Class-forName-类加载执行静态代码块"><a href="#Class-forName-类加载执行静态代码块" class="headerlink" title="Class.forName()类加载执行静态代码块"></a>Class.forName()类加载执行静态代码块</h3><p>在调用forName()方法时，会导致类加载。而静态代码块会在类加载时执行且只执行一次</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*public class Person &#123;</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;静态代码块执行&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;/*</span></span><br><span class="line"><span class="comment">Class.forName(&quot;Reflection.Examp3.Person&quot;);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">静态代码块执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="通过Class类实例化对象"><a href="#通过Class类实例化对象" class="headerlink" title="通过Class类实例化对象"></a>通过Class类实例化对象</h2><ol><li>newInstance()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class cls = Class.forName(<span class="string">&quot;Reflection.Examp2.User&quot;</span>);</span><br><span class="line">Object user = cls.newInstance();</span><br><span class="line">System.out.println(user);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    User类的无参构造方法</span></span><br><span class="line"><span class="comment">Reflection.Examp2.User@1b6d3586</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>newInstance()方法在jdk9之后就已经过时</li><li>呢哇Instance()方法会调用对应类的构造方法</li></ol></blockquote><h2 id="通过读取属性文件实例化对象"><a href="#通过读取属性文件实例化对象" class="headerlink" title="通过读取属性文件实例化对象"></a>通过读取属性文件实例化对象</h2><p>classinfo.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">classname</span>=<span class="string">Reflection.PathCreate.User</span></span><br></pre></td></tr></table></figure><p>通过读取属性文件实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取配置文件</span><br><span class="line">FileReader fr &#x3D; new FileReader(&quot;D:\\file\\javaSE\\练习\\反射\\project\\src\\classinfo.preperties&quot;);</span><br><span class="line">&#x2F;&#x2F;获取文件</span><br><span class="line">Properties ppe &#x3D; new Properties();</span><br><span class="line">ppe.load(fr);</span><br><span class="line">fr.close();&#x2F;&#x2F;关闭流</span><br><span class="line">&#x2F;&#x2F;获取文件内容</span><br><span class="line">String classname &#x3D; ppe.getProperty(&quot;classname&quot;);</span><br><span class="line">&#x2F;&#x2F;获取Class对象</span><br><span class="line">Class cls &#x3D; Class.forName(classname);</span><br><span class="line">&#x2F;&#x2F;实例化User对象</span><br><span class="line">Object user &#x3D; cls.newInstance();</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#x2F;*</span><br><span class="line">输出：</span><br><span class="line">User类的无参构造方法</span><br><span class="line">Reflection.PathCreate.User@1b6d3586</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>通过new 关键字实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User();</span><br><span class="line">System.out.println(user1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">User类的无参构造方法</span></span><br><span class="line"><span class="comment">Reflection.PathCreate.User@4554617c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>实例化对象可以直接new，也可以通过Class类实例化对象，但是相比传统的实例化方式，后者更加灵活，只需要修改配置文件就可以实例化对象，不需要改动源码。</p><p>用读取配置文件来实例化一个对象时，如果对象的访问权限不是public或者构造方法的访问权限不是public，那么其他包中的类来实例化这个对象会抛出异常</p></blockquote><h3 id="获取类路径-src路径-下的绝对路径"><a href="#获取类路径-src路径-下的绝对路径" class="headerlink" title="获取类路径(src路径)下的绝对路径"></a>获取类路径(src路径)下的绝对路径</h3><p>我们在代码中写的路径名往往不通用，当更换操作系统或者IDE时，在运行程序可能会出现文件找不到等错误。下面介绍一种通用方式来获取文件路径。<em>这种方式只能获取类文件路径下的文件(src路径下的文件)</em></p><p>PathTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目录结构：</span></span><br><span class="line"><span class="comment">src</span></span><br><span class="line"><span class="comment">classinfo.preperties</span></span><br><span class="line"><span class="comment">Examp4</span></span><br><span class="line"><span class="comment">PathTest.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Thread.currentThread()：当前线程</span></span><br><span class="line"><span class="comment">//getContextClassLoader()：获取当前线程类的加载器</span></span><br><span class="line"><span class="comment">//getResource()：【获取资源】类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源</span></span><br><span class="line">String path1=Thread.currentThread().getContextClassLoader()</span><br><span class="line">             .getResource(<span class="string">&quot;classinfo.properties&quot;</span>).getPath();</span><br><span class="line">System.out.println(path1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：/D:/file/javaSE/%e7%bb%83%e4%b9%a0/%e5%8f%8d%e5%b0%84/project/out/production/project/classinfo.properties</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>如果路径中有中文，则中文会被URL编码，使用时要解码【java.net.URLDecoder.decode(path1,”utf-8”)】。</p></blockquote><p>上面的方式是先获取配置文件路径，在通过IO流读取，我们通过类加载器的getResourceAsStream()方法就可以获取这个IO流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取IO流</span></span><br><span class="line">InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">&quot;classinfo.properties&quot;</span>);</span><br><span class="line"><span class="comment">//读取文件内容</span></span><br><span class="line">Properties pps = <span class="keyword">new</span> Properties();</span><br><span class="line">pps.load(is);</span><br><span class="line">is.close();</span><br><span class="line"><span class="comment">//获取class名</span></span><br><span class="line">String clsname = pps.getProperty(<span class="string">&quot;classname&quot;</span>);</span><br><span class="line"><span class="comment">//通过Class对象新建对象</span></span><br><span class="line">Class cls = Class.forName(clsname);</span><br><span class="line">Object obj = cls.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Reflection.PathCreate.User@4554617c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="类加载器简述"><a href="#类加载器简述" class="headerlink" title="类加载器简述"></a>类加载器简述</h4><p>上面两种获取绝对文件路径的方式都提到了类加载器的概念。这里简单描述</p><p>当程序运行之前，类加载器负责加载用到的类。</p><p>类加载器包括启动类加载器、扩展类加载器、应用类加载器。</p><p>当加载一个类时，系统按照启动类加载器—&gt;扩展类加载器—&gt;应用类加载器的顺序搜索这个类。</p><p>启动类加载器加载的类在【jre\lib\rt.jar】中的jar包</p><p>扩展类加载器加载的类在【jre\lib\ext】文件下中jar包</p><p>应用类加载器加载的类在【classpath】中的jar包</p><h3 id="资源绑定器"><a href="#资源绑定器" class="headerlink" title="资源绑定器"></a>资源绑定器</h3><p>java.util包中提供了资源绑定器，可以直接获取类路径下的properties文件(只能获取properties文件)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle rb = ResourceBundle.getBundle(<span class="string">&quot;classinfo&quot;</span>);</span><br><span class="line">String classname = rb.getString(<span class="string">&quot;classname&quot;</span>);</span><br><span class="line">Class cls = Class.forName(classname);</span><br><span class="line">Object obj = cls.newInstance();</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>配置文件必须在类目录下</li><li>文件名不需要加后缀</li><li>默认是读取src目录下</li><li>javaEE项目应默认读取WEB-INF下的classes下的配置文件</li></ol></blockquote><h3 id="类的根路径"><a href="#类的根路径" class="headerlink" title="类的根路径"></a>类的根路径</h3><p>java中真正的类路径中存放的都是编译好的class字节码文件和其他文件，不包括java源文件。IDEA中的src就对应着这个路径。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><blockquote><p>属性相关：</p><p>public Field getField(String name) throws NoSuchFieldException, SecurityException：获取类的指定属性对象(被public修饰)</p><p>public Field[] getFields() throws SecurityException：获取类的所有属性对象数组(被public修饰)</p><p>public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException：获取类的指定属性对象</p><p>public Field[] getDeclaredFields() throws SecurityException：获取类的所有属性对象数组</p><p>构造方法：</p><p>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException：获取指定构造方法(被public修饰)</p><p>public Constructor&lt;?&gt;[] getConstructors() throws SecurityException：获取所有构造方法(被public修饰)</p><p>public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException：获取指定构造方法</p><p>public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException：获取所有构造方法</p><p>方法相关：</p><p>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>     throws NoSuchMethodException, SecurityException：返回类的指定方法(被public方法修饰)</p><p>public Method[] getMethods() throws SecurityException：返回类的所有方法(被public方法修饰)</p><p>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) </p><p>​        throws NoSuchMethodException, SecurityException：返回类的指定方法</p><p>public Method[] getDeclaredMethods() throws SecurityException：返回类的所有方法集合</p><p>其他：</p><p>public String getName()：获取类的完整名称(包名+类名)</p><p>public String getSimpleName()：获取类的名称(只有类名)</p><p>public native Class&lt;? super T&gt; getSuperclass()：获取父类的Class对象</p><p>public Class&lt;?&gt;[] getInterfaces()：获取所有实现的接口</p></blockquote><h3 id="java-lang-reflect-Field"><a href="#java-lang-reflect-Field" class="headerlink" title="java.lang.reflect.Field"></a>java.lang.reflect.Field</h3><blockquote><p>public String getName()：返回属性名</p><p>public int getModifiers()：返回修饰符代码。 应该使用<code>Modifier</code>类来解码修饰符【public static String toString(int mod)：返回修饰符代码所表示的修饰符】。</p><p>public Class&lt;?&gt; getType()：返回属性类型</p><p>public void set(Object obj, Object value)：设置obj的属性值为value</p><p>public Object get(Object obj)：返回obj的属性值</p></blockquote><h3 id="java-lang-reflect-Method"><a href="#java-lang-reflect-Method" class="headerlink" title="java.lang.reflect.Method"></a>java.lang.reflect.Method</h3><blockquote><p>public int getModifiers()：返回修饰符代码。应该使用<code>Modifier</code>类来解码修饰符【public static String toString(int mod)：返回修饰符代码所表示的修饰符】。</p><p>public Class&lt;?&gt; getReturnType()：返回一个Class对象，表示返回值类型</p><p>public String getName()：返回方法名</p><p>public Class&lt;?&gt;[] getParameterTypes()：返回参数对象列表</p><p>public Object invoke(Object obj, Object… args)<br>        throws IllegalAccessException, IllegalArgumentException, InvocationTargetException：调用对象的方法，args是可变参数列表，用来区分重载的方法</p></blockquote><h3 id="java-lang-reflect-Construct"><a href="#java-lang-reflect-Construct" class="headerlink" title="java.lang.reflect.Construct"></a>java.lang.reflect.Construct</h3><blockquote><p>public int getModifiers()：获取修饰符代码。应该使用<code>Modifier</code>类来解码修饰符【public static String toString(int mod)：返回修饰符代码所表示的修饰符】。</p><p>public Class&lt;?&gt;[] getParameterTypes()：获取所有的参数对象列表</p><p>public T newInstance(Object … initargs)<br>        throws InstantiationException, IllegalAccessException,<br>               IllegalArgumentException, InvocationTargetException：新建对象</p></blockquote><h3 id="类的反编译"><a href="#类的反编译" class="headerlink" title="类的反编译"></a>类的反编译</h3><p>通过上述方法，获取一个类所有的属性，构造方法和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;Reflection.ClassCollections.Student&quot;</span>);</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(Modifier.toString(cls.getModifiers())+<span class="string">&quot; class &quot;</span>+cls.getSimpleName()+<span class="string">&quot; &#123;&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//获取属性</span></span><br><span class="line">Field[] fields = cls.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line">sb.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    sb.append(Modifier.toString(field.getModifiers()));</span><br><span class="line">    sb.append(<span class="string">&quot; &quot;</span>+field.getType().getSimpleName());</span><br><span class="line">    sb.append(<span class="string">&quot; &quot;</span>+field.getName());</span><br><span class="line">    sb.append(<span class="string">&quot;;&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line">Constructor[] constructor = cls.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor con:constructor)&#123;</span><br><span class="line">sb.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    sb.append(Modifier.toString(con.getModifiers()));</span><br><span class="line">    sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    sb.append(cls.getSimpleName());</span><br><span class="line">    sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    Class[] paraClass = con.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; paraClass.length;i++)&#123;</span><br><span class="line">    Class curCl = paraClass[i];</span><br><span class="line">        sb.append(curCl.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span>(i != paraClass.length-<span class="number">1</span>)</span><br><span class="line">        sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&#123;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法</span></span><br><span class="line">Method[] methods = cls.getDeclaredMethods();</span><br><span class="line">cls.getMethods();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;methods.length;i++)&#123;</span><br><span class="line">Method cur = methods[i];</span><br><span class="line">    sb.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    sb.append(Modifier.toString(cur.getModifiers())+<span class="string">&quot; &quot;</span>+cur.getReturnType().getSimpleName()+<span class="string">&quot; &quot;</span>+cur.getName());</span><br><span class="line">    sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    Class[] clss = cur.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;clss.length;j++)&#123;</span><br><span class="line">    Class curCls = clss[j];</span><br><span class="line">        <span class="keyword">if</span>(j==clss.length-<span class="number">1</span>)&#123;</span><br><span class="line">            sb.append(curCls.getSimpleName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(curCls.getSimpleName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">System.out.println(sb);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">public class Student &#123;</span></span><br><span class="line"><span class="comment">public String name;</span></span><br><span class="line"><span class="comment">protected String sex;</span></span><br><span class="line"><span class="comment">private int id;</span></span><br><span class="line"><span class="comment">static boolean flag;</span></span><br><span class="line"><span class="comment"> Student(String,String)&#123;&#125;</span></span><br><span class="line"><span class="comment">public Student(String,String,int)&#123;&#125;</span></span><br><span class="line"><span class="comment">public Student()&#123;&#125;</span></span><br><span class="line"><span class="comment">private String getName()&#123;&#125;</span></span><br><span class="line"><span class="comment">public void setName(String)&#123;&#125;</span></span><br><span class="line"><span class="comment">public void printInfo(String)&#123;&#125;</span></span><br><span class="line"><span class="comment">private void printInfo()&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="访问属性-设置获取属性值"><a href="#访问属性-设置获取属性值" class="headerlink" title="访问属性(设置获取属性值)"></a>访问属性(设置获取属性值)</h3><p>获取到一个Field对象之后，我们可以设置、获取对象的这个属性值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传统方式获取设置对象的属性值</span><br><span class="line">Student stu1 &#x3D; new Student();</span><br><span class="line">stu1.name &#x3D; &quot;张&quot;;</span><br><span class="line">System.out.println(stu1.name); &#x2F;&#x2F; 张</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用反射机制</span><br><span class="line">Class stuCls &#x3D; Class.forName(&quot;Reflection.ClassCollections.Student&quot;);</span><br><span class="line">Object stu2 &#x3D; stuCls.newInstance();&#x2F;&#x2F;创建对象</span><br><span class="line">Field name &#x3D; stuCls.getDeclaredField(&quot;name&quot;);</span><br><span class="line">name.set(stu2, &quot;李四&quot;);</span><br><span class="line">System.out.println(name.get(stu2));</span><br><span class="line"></span><br><span class="line">Field sex &#x3D; stuCls.getDeclaredField(&quot;sex&quot;);</span><br><span class="line">sex.setAccessible(true);&#x2F;&#x2F;可以访问非public权限的属性</span><br><span class="line">System.out.println(sex.getName());&#x2F;&#x2F; sex</span><br><span class="line">sex.set(stu2, &quot;男&quot;); &#x2F;&#x2F; 设置 stu2对象的 sex属性值为“男”</span><br><span class="line">System.out.println(sex.get(stu2));&#x2F;&#x2F;获取输出stu2对象的sex属性</span><br></pre></td></tr></table></figure><blockquote><p>若一个属性的访问权限不是public，那么我们设置一个对象的属性值时可能出现异常(没有访问权限)，我们可以调用Field的【setAccessible(true)】来访问该属性</p></blockquote><h3 id="通过反射机制新建对象"><a href="#通过反射机制新建对象" class="headerlink" title="通过反射机制新建对象"></a>通过反射机制新建对象</h3><p>若对象没有空构造方法，我们就不能用Class对象的newInstance()方法新建对象。这时我们可以获取Class对象的有参构造方法得到Constructor对象，通过Constructor对象的newInstance()方法来新建对象</p><h3 id="获取父类信息和实现的接口信息"><a href="#获取父类信息和实现的接口信息" class="headerlink" title="获取父类信息和实现的接口信息"></a>获取父类信息和实现的接口信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 类</span></span><br><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="comment">//String 父类</span></span><br><span class="line">Class supCls = cls.getSuperclass();</span><br><span class="line">System.out.println(supCls.getSimpleName());</span><br><span class="line"><span class="comment">//String 实现的接口</span></span><br><span class="line">Class[] interfaces = cls.getInterfaces();</span><br><span class="line"><span class="keyword">for</span>(Class inf:interfaces)&#123;</span><br><span class="line">System.out.println(inf.getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Serializable</span></span><br><span class="line"><span class="comment">Comparable</span></span><br><span class="line"><span class="comment">CharSequence</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化字符逃逸</title>
      <link href="2020/12/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"/>
      <url>2020/12/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP序列化与反序列化"><a href="#PHP序列化与反序列化" class="headerlink" title="PHP序列化与反序列化"></a>PHP序列化与反序列化</h1><h2 id="PHP序列化：serialize"><a href="#PHP序列化：serialize" class="headerlink" title="PHP序列化：serialize"></a>PHP序列化：serialize</h2><p>序列化是将变量或对象转换成字符串的过程。</p><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   $_SESSION[<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;001&#x27;</span>;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;Ali&#x27;</span>;</span><br><span class="line">   var_dump(serialize($_SESSION));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出：</p><p><code>string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</code></p><p>序列化字符格式：</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><h2 id="PHP反序列化：unserialize"><a href="#PHP反序列化：unserialize" class="headerlink" title="PHP反序列化：unserialize"></a>PHP反序列化：unserialize</h2><p>反序列化是将字符串转换成变量或对象的过程。</p><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   $_SESSION[<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;001&#x27;</span>;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;Ali&#x27;</span>;</span><br><span class="line">   var_dump(unserialize(serialize($_SESSION)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出：</p><p><code>array(2) &#123; [&quot;id&quot;]=&gt; string(3) &quot;001&quot; [&quot;user&quot;]=&gt; string(3) &quot;Ali&quot; &#125;</code></p><h1 id="PHP反序列化字符逃逸"><a href="#PHP反序列化字符逃逸" class="headerlink" title="PHP反序列化字符逃逸"></a>PHP反序列化字符逃逸</h1><p><strong>成因：PHP反序列化时，对序列化格式的严格要求</strong></p><p>序列化后的元素都被{}包裹，我们在序列化对象<code>a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;</code>后加入<code>;s:3:&quot;age&quot;;s:2:&quot;12&quot;&#125;</code> 对象依然可以成功被反序列化输出。</p><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   $_SESSION[<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;001&#x27;</span>;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;Ali&#x27;</span>;</span><br><span class="line">   $str=serialize($_SESSION);</span><br><span class="line">   var_dump($str);</span><br><span class="line">   <span class="keyword">echo</span>  <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">   var_dump(unserialize($str));</span><br><span class="line">   <span class="keyword">echo</span>  <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">   $str=$str.<span class="string">&#x27;;s:3:&quot;age&quot;;s:2:&quot;12&quot;&#125;&#x27;</span>;</span><br><span class="line">   var_dump($str);</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">   var_dump(unserialize($str));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(3) &quot;001&quot; [&quot;user&quot;]&#x3D;&gt; string(3) &quot;Ali&quot; &#125;</span><br><span class="line">string(66) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;;s:3:&quot;age&quot;;s:2:&quot;12&quot;&#125;&quot;</span><br><span class="line">array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(3) &quot;001&quot; [&quot;user&quot;]&#x3D;&gt; string(3) &quot;Ali&quot; &#125;</span><br></pre></td></tr></table></figure><p>若反序列化的对象内部不符合序列化格式，反序列化时则不会正确输出。</p><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   var_dump(unserialize(<span class="string">&#x27;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&#x27;</span>));<span class="comment">//符合序列化格式规范，正确输出</span></span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">   var_dump(unserialize(<span class="string">&#x27;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Alii&quot;;&#125;&#x27;</span>));<span class="comment">//user对应的值长度为3，此处为&quot;Alii&quot;长度为4，不会正确输出</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(3) &quot;001&quot; [&quot;user&quot;]&#x3D;&gt; string(3) &quot;Ali&quot; &#125;</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure><p><strong>条件</strong>：存在字符过滤。</p><p>字符过滤分为两种情况：过滤后字符变多或过滤后字符变少。</p><p><strong>程序本身的字符过滤和反序列化对格式的严格要求</strong>构成了php反序列化字符逃逸。</p><hr><h4 id="过滤后字符变多的反序列化字符逃逸"><a href="#过滤后字符变多的反序列化字符逃逸" class="headerlink" title="过滤后字符变多的反序列化字符逃逸"></a>过滤后字符变多的反序列化字符逃逸</h4><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">$str</span>)</span>&#123;</span><br><span class="line">      $filter=<span class="string">&#x27;/1/i&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> preg_replace($filter,<span class="string">&#x27;11&#x27;</span>,$str);</span><br><span class="line">   &#125;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;001&#x27;</span>;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;Ali&#x27;</span>;</span><br><span class="line">   var_dump(serialize($_SESSION));</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">   var_dump(filter(serialize($_SESSION)));</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//    string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span></span><br><span class="line"><span class="comment">//    string(47) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;0011&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到我们的字符序列化之后经过过滤值“001”变为”0011”。</p><p>若此时我们想要让user的值变为<code>flag</code>。</p><p>我们可以尝试让id的值先为：<code>&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code></p><p>序列化输出一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>因为id字段值里没有<code>1</code>这个字符，所以过滤前后没有任何变化，让id的值为<code>1&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code>输出看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(70) &quot;a:2:&#123;s:2:&quot;id&quot;;s:26:&quot;1&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(71) &quot;a:2:&#123;s:2:&quot;id&quot;;s:26:&quot;11&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>可以看到经过过滤之后id值中的最后一个字符<code>&#125;</code>逃逸出来。多输几个<code>1</code>试试：<code>1111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code>，输出看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(73) &quot;a:2:&#123;s:2:&quot;id&quot;;s:29:&quot;1111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(77) &quot;a:2:&#123;s:2:&quot;id&quot;;s:29:&quot;11111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>可以看到此时id字段值中的后四个字符<code>g&quot;;&#125;</code>逃逸出来，所以要想让<code>&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code>都逃逸出来，我们只要在id值前面加入25个<code>1</code>即可。id值：<code>1111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code>，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(94) &quot;a:2:&#123;s:2:&quot;id&quot;;s:50:&quot;1111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(119) &quot;a:2:</span><br><span class="line">&#123;s:2:&quot;id&quot;;s:50:&quot;11111111111111111111111111111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>反序列化一下过滤后的值看看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(unserialize(<span class="string">&#x27;a:2:&#123;s:2:&quot;id&quot;;s:50:&quot;11111111111111111111111111111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&#x27;</span>));</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(50) &quot;11111111111111111111111111111111111111111111111111&quot; [&quot;user&quot;]&#x3D;&gt; string(4) &quot;flag&quot; &#125;</span><br></pre></td></tr></table></figure><p>成功将user值变为了<code>flag</code>。</p><hr><h4 id="过滤后字符变少的反序列化字符逃逸"><a href="#过滤后字符变少的反序列化字符逃逸" class="headerlink" title="过滤后字符变少的反序列化字符逃逸"></a>过滤后字符变少的反序列化字符逃逸</h4><p>例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">$str</span>)</span>&#123;</span><br><span class="line">      $filter=<span class="string">&#x27;/b/i&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> preg_replace($filter,<span class="string">&#x27;&#x27;</span>,$str);</span><br><span class="line">   &#125;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;id&#x27;</span>]=<span class="string">&#x27;00b&#x27;</span>;</span><br><span class="line">   $_SESSION[<span class="string">&#x27;user&#x27;</span>]=<span class="string">&#x27;Ali&#x27;</span>;</span><br><span class="line">   var_dump(serialize($_SESSION));</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">   var_dump(filter(serialize($_SESSION)));</span><br><span class="line"><span class="comment">// 输出：  </span></span><br><span class="line"><span class="comment">//    string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;00b&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span></span><br><span class="line"><span class="comment">//    string(45) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;00&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到我们的字符序列化之后经过过滤值“00b”变为”00”。</p><p>若此时我们想要让user的值变为<code>flag</code>。</p><p>我们可以尝试让id的值先为：<code>&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code></p><p>序列化输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>可以看到id字段值不变，若此时id字段名可控，将id名变为<code>b</code>，输出一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(68) &quot;a:2:&#123;s:1:&quot;b&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(67) &quot;a:2:&#123;s:1:&quot;&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>可以看到<code>b</code>字段名变成了<code>&quot;</code>向后吞了一位，在吞8位就到我们构造的值那里了，将字段名变为8个b试试：<code>bbbbbbbb</code>，输出看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(75) &quot;a:2:&#123;s:8:&quot;bbbbbbbb&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(67) &quot;a:2:&#123;s:8:&quot;&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>我们的字段名经过过滤后变为：<code>&quot;;s:25:&quot;</code>了，所以我们只需要在我们构造的值前面继续构造就可以了。将字段名原先构造的值变为：<code>&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;</code>，输出一下看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过滤前：</span><br><span class="line">string(83) &quot;a:2:&#123;s:8:&quot;bbbbbbbb&quot;;s:33:&quot;&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br><span class="line">过滤后：</span><br><span class="line">string(75) &quot;a:2:&#123;s:8:&quot;&quot;;s:33:&quot;&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure><p>反序列化输出一下最终构造好的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   var_dump(unserialize(&#39;a:2:&#123;s:8:&quot;&quot;;s:33:&quot;&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&#39;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array(2) &#123; [&quot;&quot;;s:33:&quot;&quot;]&#x3D;&gt; string(1) &quot;a&quot; [&quot;user&quot;]&#x3D;&gt; string(4) &quot;flag&quot; &#125;</span><br></pre></td></tr></table></figure><p>成功修改user的值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> php反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
