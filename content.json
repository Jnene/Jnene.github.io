{"meta":{"title":"NeNe's Blog","subtitle":"","description":"Welcome my frimend","author":"J Nene","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Linux账户管理、进程管理","slug":"Linux用户管理、进程管理","date":"2022-03-24T07:36:13.000Z","updated":"2022-03-24T08:49:36.056Z","comments":true,"path":"2022/03/24/Linux用户管理、进程管理/","link":"","permalink":"http://example.com/2022/03/24/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux账户管理、进程管理[toc] 前言​ Linux是多用户多任务操作系统，所以熟悉用户账户和进程的管理是十分有必要的。 账户管理账户概述Linux中账户分为用户账户和组账户。 用户账户分为普通用户账户和管理员用户账户。用户账户可以在系统上进行日常工作，管理员账户用来管理账户和系统。管理员账户有系统操作的最高权限。即使系统有一个人在使用，在日常工作中建议使用普通用户账户登录，以此防止管理员账户操作不当损害系统。 组是用户的集合。组账户分为标准组和私有组。当创建一个用户时，不指定组账户默认创建和用户同名的私有组；如果想让用户加入标准组，应在创建用户时指定。 一个用户可以有多个组，当一个用户属于多个组时，登录后的组是主组，其它的组为附加组。 账户系统文件 /etc/passwd：存放账户信息 该文件中的字段以:分隔，字段含义从左到右依次为：用户名、用户口令(加密)、用户ID(UID，管理员账户UID为0，系统账户UID为1-499，普通用户UID为500及以后)、组ID(GID，用户登录以后的主组ID)、存放用户全名地理位置等信息、用户宿主目录、shell版本 该文件所有用户可读 /etc/shadow：存放账户口令信息 该文件root用户可读 /etc/group：存放组的信息 该文件字段含义从左到右依次为：组名、组口令(加密)、组标识(UID)、组成员(成员之间用逗号分隔) 该文件所有用户可读 /etc/gshadow：定义用户口令、组管理员等信息 该文件字段含义从左到右依次为：组名、组口令(加密)、组管理员、组成员(成员之间用逗号分隔) 管理账户管理用户账户 添加用户 语法：useradd [&lt;参数&gt;] &lt;用户名&gt; 参数： -g：指定主组 -G：指定附加组 -u：指定用户id -d：指定用户宿主目录，如果不存在，可以用-m参数创建 修改用户 语法：usermod [&lt;参数&gt;] &lt;用户名&gt; 参数： -l &lt;新用户名&gt;：修改用户名 其它参数和添加用户参数相同 删除用户 语法：userdel [-r] &lt;用户名&gt; -r表示删除用户的同时删除用户目录 管理组账户 添加组账户 语法：groupadd [&lt;参数&gt;] &lt;组名&gt; 参数： -g：指定组ID -r：创建系统工作组，组id小于500 修改组账户 语法：groupadd [&lt;参数&gt;] 参数： -n &lt;组名&gt; &lt;用户名&gt;：将用户添加至指定组 删除组账户 语法：groupdel &lt;组名&gt; 通过查看/etc/group文件可以判断组是否删除成功 密码管理修改密码语法：passwd [&lt;参数&gt;] &lt;用户名&gt; 参数： -S：查看口令状态 -d：删除口令 -l：锁定口令，不允许用户修改 -u：解锁口令 -e：密码过期，强制用户下次登录修改密码 提示：root用户可以修改所有人的密码，普通用户只能修改自己的密码 设置密码时效为了保证系统安全，最好每隔一段时间就修改密码。密码时效规定了口令最长有效天数、口令修改的最短间隔时间、口令过期提前几天提醒等信息。 对于未来要创立的用户，设置密码时效通过修改/etc/login.defs文件 对于已经存在的账户，用chage命令来更改密码时效 语法：chage [&lt;选项&gt;] &lt;用户名&gt; 选项： -M：口令最长有效天数 -W：口令过期提前几天提醒 -l：当前口令的详情信息 用户和组状态通过下列命令来查看当前用户和组信息 whoami：当前登录用户 id：用户信息和用户当前组信息 groups：用户所在组 newgrp &lt;组名&gt;：切换组 权限管理进程管理","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"UML之用例图、类图、时序图","slug":"UML之用例图、类图、时序图","date":"2022-03-23T11:23:48.000Z","updated":"2022-03-24T08:51:33.786Z","comments":true,"path":"2022/03/23/UML之用例图、类图、时序图/","link":"","permalink":"http://example.com/2022/03/23/UML%E4%B9%8B%E7%94%A8%E4%BE%8B%E5%9B%BE%E3%80%81%E7%B1%BB%E5%9B%BE%E3%80%81%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"","text":"UML之用例图、类图、时序图[toc] 什么是UML统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。 用例图用例图站在用户的角度展示系统的功能。主要展示2个信息：哪些用户使用系统和用户能够使用的系统功能 组成 用户 使用系统的角色。如超市管理系统的售货员、会员等。 用户在用例图中用一个小人表示 用例 系统的具体功能。如图书管理系统的查询图书馆功能、添加图书功能等。 在用例图中用椭圆表示 关系 用例图中的关系有关联、泛化、包含和扩展。 关联：表示用户和用例之间的关系。用实线标识。 泛化：类似面向对象的继承关系，可以用在用户和用户之间，也可以用在用例和用例之间。用空心箭头标识，箭头指向父类。 包含：当用例特别复杂，可以将用例抽象成一个大的功能，再让该用例指向小功能的用例。用虚线箭头标识，箭头指向小功能的用例。 扩展：表示功能的拓展功能。用虚线箭头标识，箭头指向被拓展的用例。 类图类图描述了类的方法属性以及和其他类之间的关系 类图的组成一个类的类图由3个矩形组成，其中第一个矩形是类名，第二个矩形是类的属性，第三个矩形是类的方法。 比如定义一个Employee类，代码如下： 1234567891011121314class Employee&#123; private Integer empId; //员工编号 private String empName; //员工姓名 private Double empSalary; //员工薪资 private Integer empDeptId; //员工部门编号 private boolean getOffWork(Integer empId)&#123; //签到 &#125; public void work()&#123; //工作 &#125; &#125; 该类的类图如图所示： 类图包含的关系 泛化 表示类的继承关系。用实线空心箭头标识，箭头指向父类。 123class Animal&#123;&#125;class Brid extends Animal&#123;&#125; 实现 表示接口和类的实现关系。用虚线空心箭头标识，箭头指向接口。 123interface Brid&#123;&#125;class Sparrow implements Brid&#123;&#125; 关联 表示类是另一个类的属性。用实线箭头标识，箭头指向属性类。 12345class Cat&#123; Driver driver;&#125;class Driver&#123;&#125; 聚合 是特殊的关联关系，表示类是另一个类的属性，同时该属性类不止一个，即在类中用集合或数组定义。两个类之间是部分和整体的关系，但是两者的生命周期互不影响。用实线空心菱形标识，指向整体。 12345class ClassRoom&#123; Student[] students;&#125;class Student&#123;&#125; 组合 是特殊的聚合关系。类和类之间也是部分与整体的关系，但是两者的生命周期相互影响。用实线实心菱形标识，指向整体。 12345class Human&#123; Limbs[] limbs;&#125;class Limbs&#123;&#125; 依赖 最弱的包含关系，标识一个类是另一个类的局部变量。用虚线箭头标识，指向局部变量类。 1234567class A&#123; public void method()&#123; B b = new B(); &#125;&#125;class B&#123;&#125; 时序图时序图用来说明系统某个功能内部是如何实现的，类与类之间是如何调用的。 示例以管理员查看用户信息功能为例绘制时序图 功能界面： 查看用户功能时序图： 改图有这样几个组成部分： 小人代表动作的发出者。矩形代表对象。绿色矩形代表一个方法。实线实心箭头代表一次请求，实线矩形实心箭头代表自调用。虚线箭头代表返回值。 参考链接统一建模语言 【动力节点】UML与Rational Rose__老杜 UML建模——用例图（Use Case Diagram） 用Visio画UML用例图","categories":[],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"js闭包","slug":"js闭包","date":"2022-03-22T13:17:35.000Z","updated":"2022-03-23T02:10:17.434Z","comments":true,"path":"2022/03/22/js闭包/","link":"","permalink":"http://example.com/2022/03/22/js%E9%97%AD%E5%8C%85/","excerpt":"","text":"js闭包[toc] 前言​ 做一个练手项目时有如图所示代码： ​ bug就在for循环为元素绑定单击事件的代码块中，这里for循环的i是从0-4，可是在单击事件绑定的匿名函数中i的值一直是5。 ​ 后来将绑定事件的代码放到一个函数里，将用到的参数传递给绑定事件的函数，问题就解决了 虽然问题解决了，但始终不明白为什么会这样，网上查阅资料发现是闭包的问题，下面就闭包写出我的看法 什么是闭包​ 在函数中定义函数，在函数中定义的函数就是闭包。 123456function a()&#123; var num = 0; function b()&#123; alert(num); &#125;&#125; 例如在函数a中定义了函数b，函数b就是一个闭包。通过函数b能访问到在函数a中定义的局部变量。 闭包的作用通过闭包可以延长局部变量的生命周期。局部变量是在函数内部定义的变量，函数被调用，局部变量被创建，函数调用完成，局部变量被销毁。 1234567function a()&#123; var num = 0; num += 1; return num;&#125;alert(a()); // 0alert(a()); // 0 如果函数返回一个闭包函数，在闭包函数中又返回了函数的一个局部变量，此时函数的返回值闭包函数赋值给一个变量，由于变量是全局变量，会在整个程序执行完毕后销毁，闭包函数也就随之存在，当然，闭包函数中调用的局部变量也会一直存在。 12345678910function a()&#123; var num = 0; return function()&#123; num += 1; return num; &#125;;&#125;var b = a();alert(b()); // 1alert(b()); // 2 此时在分析前言中遇到的问题就会明白，在for循环中定义的局部变量i并没有被销毁，值一直是5，每次单击事件都会访问i的值。 参考链接关于js for循环click事件 JavaScript 闭包","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"mysql事务概述","slug":"mysql事务概述","date":"2022-03-22T07:22:32.000Z","updated":"2022-03-22T09:26:05.693Z","comments":true,"path":"2022/03/22/mysql事务概述/","link":"","permalink":"http://example.com/2022/03/22/mysql%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/","excerpt":"","text":"mysql事务概述[toc] 什么是事务​ 事务在mysql中是一组DML语句的合集。 ​ 事务可以抽象成现实场景，比如从账户A向账户B转钱。首先要将A账户的钱减去，然后让账户B的钱增加。转账的操作就是一个事务。 事务的特性​ 事务遵循ACID四大特性。 原子性(Atomicity)​ 事务是最小的执行单位，事务中的DML语句要么都执行成功，如果有一个语句执行失败，事务就要回滚到初始状态。 一致性(Consistency)​ 事务的执行结果要和现实业务逻辑相似，执行结果要符合预期。 隔离性(Isoladon)​ 多个事务并发执行，事务之间互不影响和干扰。 持久性(Durability)​ 事务提交后数据应被保存到硬盘中。 事务的隔离级别根据事务的隔离性，事务有4大隔离级别，隔离级别越高，事务并发执行的效率就越低。 读未提交(READ UNCOMMITED)​ 一个事务可以读取到另一个事务未提交的数据。读未提交会带来脏读问题。 ​ 脏读是指读取到的数据没有意义，事务未提交之前，表中的数据都是可能随时改变的。 读已提交(READ COMMITED)​ 一个事务只能读取到另一个事务提交的数据。读已提交解决了脏读的问题，但又带来了不可重复读的问题。 ​ 不可重复读是指不能读取到某个时间点之前表中的数据，读已提交读到的数据都是真实的。 可重复读(REPEATABLE READ)​ 当一个事务开启后，只能读到事务开启前的数据，其他事务对数据的修改无法读到。可重复读解决了不可重复读的问题，但又带了幻读的问题。 ​ 幻读是指从表中读取到的数据是不真实的，只能读到事务开启之前表中的数据，再此期间读取不到表中后来更新的数据。 ​ 幻读只是读取不到表中的数据，但是如果有另一个事务插入一条主键为“1001”的数据并提交，在本事务中又插入了一条主键为“1001”的数据，这是不允许的。 串行/序列化(SERIALIZABLE)​ 最高的隔离级别，不允许多个事务同时对一张表进行操作。 ​ 串行/序列化隔离级别解决了脏读、不可重复读、幻读，但是多事务并发执行效率低。 mysql中有关事务的操作 开启事务：start transaction; 开启只读事务：start transaction read only 只读事务只能执行DQL语句，不能执行DML语句，在执行DDL语句之后事务自动提交结束。 提交事务：commit; 事务回滚：rollback; 设置事务保存点：savepoint 【保存点名称】 rollback语句只能回滚到事务开启前的状态，不能回滚到事务开启后某个语句执行之前的状态，用savepoint设置保存点后，就可以用rollback to 【保存点名称】回滚到事务开启后某个语句执行之前的状态。 查看事务隔离级别：select @@tx_isolation; 设置事务隔离级别 设置会话级隔离级别：set transaction isolation level【隔离级别】 设置全局隔离级别：set global transaction isolation level【隔离级别】 参考链接mysql事务隔离级别与设置mysql笔记 第14篇事务讲解【Java工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网老杜带你学_mysql入门基础（mysql基础视频+数据库实战)_哔哩哔哩_bilibili p102-p112","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"ajax同步和异步的选择","slug":"ajax同步和异步的选择","date":"2022-03-21T11:48:40.000Z","updated":"2022-03-21T12:24:07.560Z","comments":true,"path":"2022/03/21/ajax同步和异步的选择/","link":"","permalink":"http://example.com/2022/03/21/ajax%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E9%80%89%E6%8B%A9/","excerpt":"","text":"ajax同步和异步的选择[toc] ajax简单介绍​ 使用ajax技术可以让我们不用刷新网页就可以向服务器获取需要的数据并用js把他显示在页面。ajax的核心是XMLHttpRequest对象(后文简称xhr对象)，使用xhr对象就可以和服务器交换数据。 ​ xhr对象的open()方法可以帮助我们和服务器建立连接，open()方法需要我们传入open(method, url, async)三个参数，其中async参数规定了ajax是异步还是同步，async的默认值为true，也就是说我们如果省略async参数的话默认就是异步ajax。 ​ 异步指的是当ajax请求发出后，js不用等待xhr回调函数的执行完毕，继续执行后续代码；如果是同步ajax则js需要等xhr的回调函数执行完毕后执行后续代码。 ajax的一个错误使用场景 假设我们有图示的修改用户信息的模态框，实现这个模态框页面的逻辑如下： ajax向服务器获取部门信息(这是因为部门信息在实际业务逻辑中可能会发生改变，需要动态获取) 显示模态框，将获取的部门信息填充到下拉列表 ajax向服务器获取要修改的用户信息 将用户信息填充到模态框表单中 对应的伪代码如下： 12345678910111213141516//1.ajax向服务器获取部门信息(这是因为部门信息在实际业务逻辑中可能会发生改变，需要动态获取)var xhr1 = new XMLHttpRequest();xhr1.open(method, url, true);xhr1.onreadystatechange = function ()&#123; //2.显示模态框，将获取的部门信息填充到下拉列表 &#125;;xhr1.send();//3.ajax向服务器获取要修改的用户信息var xhr2 = new XMLHttpRequest();xhr2.open(method, url, true);xhr2.onreadystatechange = function ()&#123; //4.将用户信息填充到模态框表单中 &#125;;xhr2.send(); ​ 根据上述代码，xhr1对象为异步ajax。假设代码进行到第四步，我们的模态框还没渲染好，那么向模态框中填充数据就会出问题。合理的逻辑应该是模态框渲染完毕之后我们在进行后续操作，所以xhr1对象应该建立为同步ajax。 总结​ 异步ajax虽然保证了代码执行的效率，但是也要根据业务逻辑的前后关系来设计代码，不要盲目使用ajax","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"mybatis运行过程源码分析","slug":"mybatis运行过程源码分析","date":"2022-03-17T07:22:06.000Z","updated":"2022-03-18T08:26:19.728Z","comments":true,"path":"2022/03/17/mybatis运行过程源码分析/","link":"","permalink":"http://example.com/2022/03/17/mybatis%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"mybatis运行过程源码分析[toc] 前言​ 了解mybatis运行流程是mybatis插件开发的前提，下面根据mybtais最基本的流程来分析mybatis运行过程 mybatis版本 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 测试代码 1234567891011121314151617public class Main &#123; @Test public void test() throws IOException&#123; /*1.通过SqlSessionFactoryBuilder获取SqlSessionFactory对象*/ InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); /*2.获取SqlSession对象*/ SqlSession sqlSession = sqlSessionFactory.openSession(); /*3.获取接口的实现对象(MapperProxy)*/ EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class); /*4.执行增删改查*/ Emp emp = empMapper.selectByPrimaryKey(1); System.out.println(emp); &#125; &#125; 流程分析1.创建SqlSessionFactory对象整体流程 创建SqlSessionFactoryBuilder对象，调用build方法传入InputStream参数 步入build方法 调用SqlSessionFactoryBuilder对象中build的重载方法，继续步入该方法 该方法定义了一个SqlSessionFactory接口并初始化后返回，我们重点关注SqlSessionFactory接口的初始化过程，注意，我们在第一步中创建的InputStream不需要我们手动调用它的close方法，这是因为在build方法中该I/O流已经被关闭 build方法中SqlSessionFactory接口的初始化流程我们看try-catch语句块，首先定义了XMLConfigBuilder的示例parser，该对象的作用是创建一个Configuration对象，该对象中定义了xml配置文件的相关信息。 重点关注SqlSessionFactory的对象是如何创建的，首先调用SqlSessionFactoryBuilder对象的build的另一个重载方法，并用parser对象的parse方法创建一个Configuration对象作为参数传入，我们先看parse方法创建Configuration对象的流程再看build方法的执行流程 parse方法创建Configuration对象的流程步入该方法 this.parsed的初始值是false，这保证Configuration对象不会被重复创建 接着步入parseConfiguration方法 该方法主要是用来解析mybatis的xml配置文件，该方法的参数为mybatis-config.xml的根节点configuration 以this.propertiesElement(root.evalNode(&quot;properties&quot;));为例，该语句的作用就是解析mybatis-config.xml文件中配置的properties标签中的内容，具体执行流程如下图： 由于都是xml解析相关的内容，这里不详细分析 build方法的执行流程步入该方法 该方法新建了一个DefaultSqlSessionFactory对象，这说明我们创建的SqlSessionFactory对象是一个DefaultSqlSessionFactory对象。继续步入DefaultSqlSessionFactory对象的构造方法 该构造方法将传入的Configuration对象赋值给了DefaultSqlSessionFactory对象的属性。 至此，SqlSessionFactory创建完成 2.获取SqlSession对象步入openSession()方法 步入openSessionFromDataSource方法 前面几句是关于环境和事务的设置，这里重点关注Executor executor = this.configuration.newExecutor(tx, execType);，该语句创造了一个执行器对象，该对象主要用来执行sql语句。 步入newExecutor方法 该方法首先根据executor的不同类型创建不同的executor对象，关于executor的类型mybatis官方文档中有说明，该属性被配置在mybatis-config.xml的setting标签中。 然后判断我们是否开启了二级缓存，如果开启，就用CachingExecutor包装我们刚刚创建的executor对象。 注意最后executor对象又被Executor executor = (Executor)this.interceptorChain.pluginAll(executor);语句包装，改包装过程涉及到插件的知识，这里不详细说明 至此我们回到刚刚的openSessionFromDataSource方法，var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);该语句将configuration和executor对象封装至SqlSession对象，至此，SqlSession对象获取完成 3.获取接口的实现对象步入sqlSession.getMapper()方法 继续步入this.configuration.getMapper(type, this)方法 继续步入this.mapperRegistry.getMapper(type, sqlSession)方法 该方法声明了MapperProxyFactory对象，并用该对象去创建MapperProxy对象，步入创建MapperProxy对象的过程方法return mapperProxyFactory.newInstance(sqlSession); 该方法首先创建了一个MapperProxy对象，注意，该对象实现了InvocationHandler接口 步入this.newInstance(mapperProxy)方法 该方法创建了我们传入接口的代理，使用的方式是JDK动态代理。 至此，接口的实现对象创建完成 参考链接JDK动态代理 尚硅谷MyBatis实战教程全套完整版 p71-p78 深入浅出MyBatis技术原理与实战 第六章 MyBatis的解析和运行原理","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"mybatis高效获取SqlSession","slug":"mybatis高效获取SqlSession","date":"2022-03-16T08:15:55.000Z","updated":"2022-03-16T08:47:21.186Z","comments":true,"path":"2022/03/16/mybatis高效获取SqlSession/","link":"","permalink":"http://example.com/2022/03/16/mybatis%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96SqlSession/","excerpt":"","text":"mybatis高效获取SqlSession[toc] SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession的作用域和生命周期SqlSessionFactoryBuilder主要用来创建SqlSessionFactory实例，在创建完SqlSessionFactory实例之后不再使用。 SqlSessionFactorySqlSessionFactory用于创建SqlSession对象。在项目中通常需要频繁创建SqlSession对象，这是因为SqlSession对象在使用后应立刻关闭。所以SqlSessionFactory应该作用于整个项目且只创建一个实例。 SqlSession用于执行增删改查操作或创建接口映射对象，在使用后应立即关闭。所以SqlSession的实例应该只在方法中被创建。另外，SqlSession是非线程安全的，在多线程环境中应考虑线程安全问题 SqlSessionFactoryUtil类的设计结合综上所述，采用单例模式中的双重校验机制来设计代码 示例代码 1234567891011121314151617181920212223public class SqlSessionFactoryUtils &#123; private static SqlSessionFactory sqlSessionFactory = null; private SqlSessionFactoryUtils()&#123;&#125; public static SqlSession getSqlSession()&#123; if(sqlSessionFactory == null)&#123; synchronized (SqlSessionFactoryUtils.class)&#123; if(sqlSessionFactory == null)&#123; InputStream is = null; try &#123; is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; &#125; &#125; return sqlSessionFactory.openSession(); &#125;&#125; 参考链接mybatis作用域和生命周期 设计模式——单例模式 多并发线程安全 深入浅出MyBatis技术原理与实战 第二章 2.4部分","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"设计模式——单例模式","slug":"设计模式——单例模式","date":"2022-03-15T07:06:05.000Z","updated":"2022-03-16T12:02:30.637Z","comments":true,"path":"2022/03/15/设计模式——单例模式/","link":"","permalink":"http://example.com/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式——单例模式[toc] 什么是单例模式面向对象思想的一种设计方式。适用于创建一个全局可访问的唯一的实例对象 应用场景 I/O和数据库的连接操作 WEB中的计数器，不用每次刷新就更新数据库，而是先缓存起来 单例模式的实现实现要求 类不能被实例化(构造方法私有) 提供唯一的实例化对象 全局可获取实例化对象 懒汉式–线程不安全特点 lazy加载，节省内存资源 线程不安全 代码实现 123456789101112public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式–线程安全特点 lazy加载 线程安全但getInstance()效率低 代码实现 123456789101112public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饿汉式特点 非lazy加载，内存资源容易浪费 线程安全 代码实现 123456789public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 通过loadclasser机制加载实例，不能确定是第一次使用时加载还是其它类调用加载 双重校验锁（DCL–Double Check Locked）特点 lazy加载 线程安全 代码实现 12345678910111213141516public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 与懒汉式–非线程安全方式相比，DCL机制缩小了同步代码范围，当instance被创建好后，就不会出现线程安全问题，多线程可以异步执行 内部静态类特点 lazy加载 线程安全 代码实现 1234567891011public class Singleton&#123; private static class InClass&#123; private final static INSTANCE = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return Inclass.INSTANCE; &#125;&#125; 与饿汉式相比，该方式利用内部静态类的加载机制，只有调用getInstance()方法时，内部静态类被加载，才会创建INSTANCE对象，达到延迟加载的效果。 参考链接菜鸟教程——单例模式 静态内部类加载机制","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"线程安全——Java","slug":"Java线程安全","date":"2022-03-15T02:26:50.000Z","updated":"2022-03-15T04:23:24.418Z","comments":true,"path":"2022/03/15/Java线程安全/","link":"","permalink":"http://example.com/2022/03/15/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","excerpt":"","text":"线程安全——Java[toc] 导致线程安全问题的原因 线程之间共享变量 线程对共享变量修改 如何解决线程安全问题保证并发的原子性、可见性、顺序性 原子性​ 保证一个操作要么都执行，要么都不执行。以取款为例，假设我们取款分为2步，第一步取钱，第二部更新余额。如果完成第一步之后出现异常导致第二步没有执行，就会出现问题。 可见性​ 保证变量的值被修改后能够立即获取变量被修改后的值。在内存模型中，CPU直接操作缓存，再将操作后的结果更新到内存。如果缓存中的内容没有被更新到内存，内存中的内容又被其它线程获取，就会导致可见性问题。 顺序性​ 保证多线程并发下指令能够顺序执行。CPU为了执行效率会对指令进行重排列，即代码不一定是按顺序执行。在单线程中，虽然会重排列指令，但因为有变量之间的依赖关系所以即使指令重排列，最后的结果仍然是正确的。 1234int i &#x3D; 1; &#x2F;&#x2F;指令1int j &#x3D; 2; &#x2F;&#x2F;指令2i &#x3D; j + 1; &#x2F;&#x2F;指令3j &#x3D; i + 1; &#x2F;&#x2F;指令4 上面代码的执行顺序可能是指令1--&gt;指令2--&gt;指令3--&gt;指令4，也有可能是指令2--&gt;指令1--&gt;指令3--&gt;指令4。指令3一定会在指令2之后执行，指令4一定会在指令3执行之后执行 在多线程环境中，失去的指令之间的依赖关系，就可能导致程序出错 123456789&#x2F;&#x2F;线程1:context &#x3D; loadContext(); &#x2F;&#x2F;语句1inited &#x3D; true; &#x2F;&#x2F;语句2&#x2F;&#x2F;线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 在线程1中，语句2和语句1没有依赖关系，就可能导致语句2执行，接着如果不执行语句1而顺序执行线程2中的代码，就会导致context没有被初始化而报错 java解决线程安全问题使用synchronized对线程进行同步。 synchronized保证原子性、可见性、顺序性synchronized的作用是给可能出现线程安全问题的代码块加上锁，当有线程执行该代码块时，就会先看看有没有其它进程在执行该代码块，如果有的话就等待进程执行完毕在执行代码块；如果没有的话就执行代码块，并加上锁防止其它进程在本进程执行过程中执行。 由于线程之间排队执行代码，代码实在调用完毕之后被其它线程调用的，所以synchronized解决了线程安全问题，保证了多线程并发下的原子性、可见性和顺序性 synchronized的使用synchronized作用于代码块1234567//语法public void method()&#123; //方法体 synchronized(共享变量)&#123; //代码... &#125;&#125; 线程在执行同步代码前，先看共享变量是否被占用，如果占用就等待。优势在于同步范围可控，执行效率高 synchronized作用于实例方法—对象锁12345678910//语法public synchronized void method()&#123; //方法体&#125;//相当于下面写法public void method()&#123; synchronized(this)&#123; //方法体 &#125;&#125; 线程在执行方法前，先看该方法的对象是否被占用，如果占用就等待。优势在于方便，适用于同步整个方法 synchronized作用于静态方法—类锁1234//语法public synchronized static void method()&#123; //方法体&#125; 线程在执行方法前，先看该方法所属类的实例是否被占用，如果占用就等待 参考链接内存模型相关概念 老杜java线程安全部分 p780-p796 ​","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"java网络编程","slug":"java网络编程","date":"2021-09-26T08:23:03.000Z","updated":"2021-09-26T14:54:15.449Z","comments":true,"path":"2021/09/26/java网络编程/","link":"","permalink":"http://example.com/2021/09/26/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"java网络编程[toc] 计算机网络基本概念概述什么是计算机网络计算机网络就是将在不同地方的多台计算机连接起来，实现资源的传输、共享。 计算机网络三要素协议若计算机之间想要通讯，就必须遵循相同的协议。网络体系结构分为7层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层,，实际应用中一般分为5层(7层太过理想化，难以实现)：应用层、传输层、网络层、数据链路层、物理层。 应用层：负责将数据转换为二进制 传输层：负责将二进制封装成报文 网络层：负责报文分组 数据链路层：负责数字信号到电路信号的映射 物理层：发送数据 每一层都有协议来完成一些功能。比如应用层协议有：HTTP(超文本传输协议)、FTP(文件传输协议)、SMTP(邮件协议)；传输层协议有：TCP、UDP；网络层协议：IP。 UDP协议UDP是面向无连接的不可靠协议。数据传输过程中可能会造成数据丢失。常用来发送一些不重要的数据，比如视频等。 TCP协议TCP是面向连接的可靠协议，数据传输安全但相较于UDP协议来说传输效率慢。面向连接是指如果两台计算机进行通信，必须要3次握手。 ip地址网络中用来标识一台主机。 端口号用来标识一台主机上的进程。每一个进程的端口号都不能相同。 端口号有两个字节组成，数据范围从0到65535，其中1024之前的端口号用户不能自己分配使用，由计算机系统来分配使用。 一些常用的端口号： http协议：80 mysql：3306 tomcat：8080 注：这些只是默认端口号，端口号可以任意指定，只要不重复即可 windows中进程相关的代码 netstat -ano：查询所有进程信息 netstat -ano | findstr “端口号”：查询指定端口号进程 taskkill -f -pid 进程号：杀死指定进程 不同协议的端口号可以相同，比如一个UDP进程的端口号为1028，则TCP进程的端口号也可以为1028。 java实现网络编程java网络编程相关类都被封装到【java.net.*】包下。实现网络编程的两个重要的类就是【java.net.Socket】和【java.net.ServerSocket】，使用Socket类我们就可以进行两台计算机之间的通信和数据共享。 Socket通过IO流来传输共享信息。 两个类都有IO异常，需要在编译前处理 java.net.SocketSocket类布置在客户端，实现客户端的套接字(套接字就是两台计算机之间通信的端点，它包括IP地址和端口号)。 构造方法 Socket(InetAddress address, int port)：连接指定的服务器 常用方法 public InputStream getInputStream() throws IOException：获取网络输入流。用于接受服务器返回的数据。 public OutputStream getOutputStream() throws IOException：获取网络输出流。用于向服务器发送数据。 public void close() throws IOException：用于关闭套接字连接。 java.net.ServerSocketServerSocket类布置在服务器端，实现服务器端的套接字 构造方法 public ServerSocket(int port) throws IOException：实现服务器端的套接字，指定服务区端口号为port 常用方法 public Socket accept() throws IOException：获取连接服务器的套接字。服务器通过改对象获取的Socket对象来接受和向客户端发送数据。 public void shutdownOutput() throws IOException：关闭客户端的输出流，并在流的末尾加上结束标记，之前发送的数据正常发送。 下面用个小例子来熟悉这些基本方法的使用 服务器代码 123456789101112131415//1.创建服务器套接字，端口号为：1028ServerSocket server = new ServerSocket(1028);//2.接受客户端套接字Socket socket = server.accept();//3.用IO流接受客户端的数据InputStream is = socket.getInputStream();byte[] infos = new byte[1024];is.read(infos);System.out.println(&quot;客户端信息：&quot; + new String(infos));//4.用IO流向客户端发送数据OutputStream os = socket.getOutputStream();os.write(&quot;收到信息&quot;.getBytes(StandardCharsets.UTF_8));//5.关闭套接字server.close();socket.close(); 客户端代码 123456789101112//1.创建客户端套接字，服务器为 127.0.0.1:1028Socket socket = new Socket(&quot;127.0.0.1&quot;,1028);//2.获取客户端输出流，向服务器发送数据OutputStream os = socket.getOutputStream();os.write(&quot;你好服务器&quot;.getBytes(StandardCharsets.UTF_8));//3.获取客户端输入流，接受服务器端的数据InputStream is = socket.getInputStream();byte[] infos = new byte[1024];is.read(infos);System.out.println(&quot;服务器消息：&quot; + new String(infos));//4.关闭套接字连接socket.close(); 写完代码后，我们需要先开启服务器，在运行客户端代码。 服务器输出：【客户端信息：你好服务器】 客户端输出：【服务器消息：收到信息】 需要注意的是，ServerSocket对象没有getInputStream()方法和getOutputStream()方法，我们需要用Socket对象的IO流对象来和客户端进行交互。 但是上述代码有个问题，服务器端只能接受一个客户端的消息，我们可以把上面的2-5步写到死循环里，这样只要我们不关闭服务器，服务器就会一直接受客户端的消息 服务器代码： 1234567891011121314151617//1.创建服务器套接字，端口号为：1028ServerSocket server = new ServerSocket(1028);while(true)&#123; //2.接受客户端套接字 Socket socket = server.accept(); //3.用IO流接受客户端的数据 InputStream is = socket.getInputStream(); byte[] infos = new byte[1024]; is.read(infos); System.out.println(&quot;客户端信息：&quot; + new String(infos)); //4.用IO流向客户端发送数据 OutputStream os = socket.getOutputStream(); os.write(&quot;收到信息&quot;.getBytes(StandardCharsets.UTF_8)); //5.关闭套接字 socket.close();&#125;//server.close(); 需要注意的是，这里我们不需要在代码中写关闭服务器套接字的代码 经过改进后，我们的服务器已经可以处理多个客户端的信息，但是当客户端请求太多时，服务器可能处理压力大，这时候我们可以使用多线程来处理这个问题。 服务器代码： 12345678910111213141516171819202122232425//1.创建服务器套接字，端口号为：1028ServerSocket server = new ServerSocket(1076);while(true)&#123; //2.接受客户端套接字 Socket socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; //3.用IO流接受客户端的数据 InputStream is = socket.getInputStream(); byte[] infos = new byte[1024]; is.read(infos); System.out.println(&quot;客户端信息：&quot; + new String(infos)); //4.用IO流向客户端发送数据 OutputStream os = socket.getOutputStream(); os.write(&quot;收到信息&quot;.getBytes(StandardCharsets.UTF_8)); //5.关闭套接字 socket.close(); &#125;catch (Exception e)&#123; &#125; &#125; &#125;).start();&#125;//server.close(); UDP通信UDP通信的实现依靠【java.net.DatagramSocket】类来实现。 java.net.DatagramSocket构造方法 public DatagramSocket() throws SocketException：建立套接字对象，端口号由操作系统随机分配(一般用于客户端建立对象) public DatagramSocket(int port) throws SocketException：建立套接字对象并指定端口号(一般用于服务器端建立对象) 常用方法 public void connect(InetAddress address, int port)：记录服务器的IP地址和端口号，一般由客户端指定 public void disconnect()：清楚记录的服务器IP地址和端口号，一般由客户端指定 public void receive(DatagramPacket p) throws IOException：指定DatagramPacket对象接受数据 public void send(DatagramPacket p) throws IOException：发送DatagramPacket对象中的数据 public void close()：关闭套接字连接 java.net.DatagramPacketDatagramSocket主要是客户端和服务器端的连接，DatagramPacket主要负责存储连接过程中产生的数据 构造方法 public DatagramPacket(byte[] buf,int length)：构造一个DatagramPacket用于接收长度的数据包length 。length参数必须小于或等于buf.length 。 常用方法 public byte[] getData()：获取对象中存储的数据 public void setData(byte[] buf)：设置缓冲区中的数据 一个UDP通信的简单例子 服务器端 1234567891011121314//1.创建服务器端套接字，端口1028DatagramSocket ds = new DatagramSocket(1028);//2.创建DatagramPacket对象来存储传输数据byte[] infos = new byte[1024];DatagramPacket dp = new DatagramPacket(infos,infos.length);//3.接受数据ds.receive(dp);//4.获取dp中的数据String info = new String(dp.getData());System.out.println(info);//5.设置返回信息dp.setData(&quot;你好客户端&quot;.getBytes(StandardCharsets.UTF_8));//6.发送返回信息ds.send(dp); 客户端 12345678910111213//1.建立客户端套接字DatagramSocket ds = new DatagramSocket();//2.建立连接ds.connect(InetAddress.getByName(&quot;127.0.0.1&quot;),1028);//3.存储要发送的信息byte[] infos = new byte[1024];DatagramPacket dp = new DatagramPacket(infos, infos.length);dp.setData(&quot;你好服务器&quot;.getBytes(StandardCharsets.UTF_8));ds.send(dp);//4.获取服务器返回的信息ds.receive(dp);String info = new String(dp.getData());System.out.println(info); 服务器端代码优化可以参考TCP通信代码示例。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"java反射机制","slug":"java反射机制","date":"2021-09-18T13:23:48.000Z","updated":"2021-10-31T14:54:33.754Z","comments":true,"path":"2021/09/18/java反射机制/","link":"","permalink":"http://example.com/2021/09/18/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Java反射机制[toc] 概述通过反射机制可以操作class文件。 反射机制的主要类包：java.lang.reflect.* 主要类 java.lang.Class：代表字节码文件 java.lang.reflect.Methon：代表字节码文件中的方法 java.lang.reflect.Filed：代表字节码文件中的属性（成员属性和类属性） java.lang.reflect.Constructor：代表字节码文件中的方法（成员方法和类方法） 获取Class类的三种方式 Class.forName(String className) 1234567Class cls1 = null;try &#123; cls1 = Class.forName(&quot;java.lang.String&quot;);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125;System.out.println(cls1); // class java.lang.String forName()是Class类的一个静态方法 参数为一个完整的类名(java.lang不能省略) class属性 1234Class cls3 = int.class;Class cls4 = String.class;System.out.println(cls3);// intSystem.out.println(cls4);// class java.lang.String Java中的任何一种类型(基本数据类型和引用数据类型)都有class属性。 getClass() 12Class cls2 = String.class;System.out.println(cls2);// class java.lang.String Object 类中有一个getClass()方法，用于获得类的字节码文件。因此，所有类都可以通过这个方法获得类对应的字节码文件 Class.forName()类加载执行静态代码块在调用forName()方法时，会导致类加载。而静态代码块会在类加载时执行且只执行一次 示例代码： 12345678910/*public class Person &#123; static &#123; System.out.println(&quot;静态代码块执行&quot;); &#125;&#125;/*Class.forName(&quot;Reflection.Examp3.Person&quot;);/* 输出： 静态代码块执行*/ 通过Class类实例化对象 newInstance() 123456789101112try &#123; Class cls = Class.forName(&quot;Reflection.Examp2.User&quot;); Object user = cls.newInstance(); System.out.println(user); /* 输出： User类的无参构造方法 Reflection.Examp2.User@1b6d3586 */&#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123; e.printStackTrace();&#125; newInstance()方法在jdk9之后就已经过时 呢哇Instance()方法会调用对应类的构造方法 通过读取属性文件实例化对象classinfo.properties 1classname=Reflection.PathCreate.User 通过读取属性文件实例化对象 12345678910111213141516171819&#x2F;&#x2F;读取配置文件FileReader fr &#x3D; new FileReader(&quot;D:\\\\file\\\\javaSE\\\\练习\\\\反射\\\\project\\\\src\\\\classinfo.preperties&quot;);&#x2F;&#x2F;获取文件Properties ppe &#x3D; new Properties();ppe.load(fr);fr.close();&#x2F;&#x2F;关闭流&#x2F;&#x2F;获取文件内容String classname &#x3D; ppe.getProperty(&quot;classname&quot;);&#x2F;&#x2F;获取Class对象Class cls &#x3D; Class.forName(classname);&#x2F;&#x2F;实例化User对象Object user &#x3D; cls.newInstance();System.out.println(user);&#x2F;* 输出： User类的无参构造方法 Reflection.PathCreate.User@1b6d3586*&#x2F; 通过new 关键字实例化对象 1234567User user1 = new User();System.out.println(user1);/* 输出： User类的无参构造方法 Reflection.PathCreate.User@4554617c*/ 实例化对象可以直接new，也可以通过Class类实例化对象，但是相比传统的实例化方式，后者更加灵活，只需要修改配置文件就可以实例化对象，不需要改动源码。 用读取配置文件来实例化一个对象时，如果对象的访问权限不是public或者构造方法的访问权限不是public，那么其他包中的类来实例化这个对象会抛出异常 获取类路径(src路径)下的绝对路径我们在代码中写的路径名往往不通用，当更换操作系统或者IDE时，在运行程序可能会出现文件找不到等错误。下面介绍一种通用方式来获取文件路径。这种方式只能获取类文件路径下的文件(src路径下的文件) PathTest.java： 12345678910111213141516/* 目录结构： src classinfo.preperties Examp4 PathTest.java*///Thread.currentThread()：当前线程//getContextClassLoader()：获取当前线程类的加载器//getResource()：【获取资源】类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源String path1=Thread.currentThread().getContextClassLoader() .getResource(&quot;classinfo.properties&quot;).getPath();System.out.println(path1);/* 输出： /D:/file/javaSE/%e7%bb%83%e4%b9%a0/%e5%8f%8d%e5%b0%84/project/out/production/project/classinfo.properties*/ 如果路径中有中文，则中文会被URL编码，使用时要解码【java.net.URLDecoder.decode(path1,”utf-8”)】。 上面的方式是先获取配置文件路径，在通过IO流读取，我们通过类加载器的getResourceAsStream()方法就可以获取这个IO流。 12345678910111213141516//获取IO流InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;classinfo.properties&quot;);//读取文件内容Properties pps = new Properties();pps.load(is);is.close();//获取class名String clsname = pps.getProperty(&quot;classname&quot;);//通过Class对象新建对象Class cls = Class.forName(clsname);Object obj = cls.newInstance();System.out.println(obj);/* 输出： Reflection.PathCreate.User@4554617c*/ 类加载器简述上面两种获取绝对文件路径的方式都提到了类加载器的概念。这里简单描述 当程序运行之前，类加载器负责加载用到的类。 类加载器包括启动类加载器、扩展类加载器、应用类加载器。 当加载一个类时，系统按照启动类加载器—&gt;扩展类加载器—&gt;应用类加载器的顺序搜索这个类。 启动类加载器加载的类在【jre\\lib\\rt.jar】中的jar包 扩展类加载器加载的类在【jre\\lib\\ext】文件下中jar包 应用类加载器加载的类在【classpath】中的jar包 资源绑定器java.util包中提供了资源绑定器，可以直接获取类路径下的properties文件(只能获取properties文件)。 12345ResourceBundle rb = ResourceBundle.getBundle(&quot;classinfo&quot;);String classname = rb.getString(&quot;classname&quot;);Class cls = Class.forName(classname);Object obj = cls.newInstance();System.out.println(obj); 注： 配置文件必须在类目录下 文件名不需要加后缀 默认是读取src目录下 javaEE项目应默认读取WEB-INF下的classes下的配置文件 类的根路径java中真正的类路径中存放的都是编译好的class字节码文件和其他文件，不包括java源文件。IDEA中的src就对应着这个路径。 常用方法java.lang.Class 属性相关： public Field getField(String name) throws NoSuchFieldException, SecurityException：获取类的指定属性对象(被public修饰) public Field[] getFields() throws SecurityException：获取类的所有属性对象数组(被public修饰) public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException：获取类的指定属性对象 public Field[] getDeclaredFields() throws SecurityException：获取类的所有属性对象数组 构造方法： public Constructor getConstructor(Class&lt;?&gt;… parameterTypes) throws NoSuchMethodException, SecurityException：获取指定构造方法(被public修饰) public Constructor&lt;?&gt;[] getConstructors() throws SecurityException：获取所有构造方法(被public修饰) public Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) throws NoSuchMethodException, SecurityException：获取指定构造方法 public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException：获取所有构造方法 方法相关： public Method getMethod(String name, Class&lt;?&gt;… parameterTypes) throws NoSuchMethodException, SecurityException：返回类的指定方法(被public方法修饰) public Method[] getMethods() throws SecurityException：返回类的所有方法(被public方法修饰) public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) ​ throws NoSuchMethodException, SecurityException：返回类的指定方法 public Method[] getDeclaredMethods() throws SecurityException：返回类的所有方法集合 其他： public String getName()：获取类的完整名称(包名+类名) public String getSimpleName()：获取类的名称(只有类名) public native Class&lt;? super T&gt; getSuperclass()：获取父类的Class对象 public Class&lt;?&gt;[] getInterfaces()：获取所有实现的接口 java.lang.reflect.Field public String getName()：返回属性名 public int getModifiers()：返回修饰符代码。 应该使用Modifier类来解码修饰符【public static String toString(int mod)：返回修饰符代码所表示的修饰符】。 public Class&lt;?&gt; getType()：返回属性类型 public void set(Object obj, Object value)：设置obj的属性值为value public Object get(Object obj)：返回obj的属性值 java.lang.reflect.Method public int getModifiers()：返回修饰符代码。应该使用Modifier类来解码修饰符【public static String toString(int mod)：返回修饰符代码所表示的修饰符】。 public Class&lt;?&gt; getReturnType()：返回一个Class对象，表示返回值类型 public String getName()：返回方法名 public Class&lt;?&gt;[] getParameterTypes()：返回参数对象列表 public Object invoke(Object obj, Object… args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException：调用对象的方法，args是可变参数列表，用来区分重载的方法 java.lang.reflect.Construct public int getModifiers()：获取修饰符代码。应该使用Modifier类来解码修饰符【public static String toString(int mod)：返回修饰符代码所表示的修饰符】。 public Class&lt;?&gt;[] getParameterTypes()：获取所有的参数对象列表 public T newInstance(Object … initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException：新建对象 类的反编译通过上述方法，获取一个类所有的属性，构造方法和方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Class cls = Class.forName(&quot;Reflection.ClassCollections.Student&quot;);StringBuilder sb = new StringBuilder();sb.append(Modifier.toString(cls.getModifiers())+&quot; class &quot;+cls.getSimpleName()+&quot; &#123;&quot;+&quot;\\n&quot;);//获取属性Field[] fields = cls.getDeclaredFields();for(Field field:fields)&#123; sb.append(&quot;\\t&quot;); sb.append(Modifier.toString(field.getModifiers())); sb.append(&quot; &quot;+field.getType().getSimpleName()); sb.append(&quot; &quot;+field.getName()); sb.append(&quot;;&quot;+&quot;\\n&quot;);&#125;//获取构造方法Constructor[] constructor = cls.getDeclaredConstructors();for(Constructor con:constructor)&#123; sb.append(&quot;\\t&quot;); sb.append(Modifier.toString(con.getModifiers())); sb.append(&quot; &quot;); sb.append(cls.getSimpleName()); sb.append(&quot;(&quot;); Class[] paraClass = con.getParameterTypes(); for(int i=0;i&lt; paraClass.length;i++)&#123; Class curCl = paraClass[i]; sb.append(curCl.getSimpleName()); if(i != paraClass.length-1) sb.append(&quot;,&quot;); &#125; sb.append(&quot;)&quot;); sb.append(&quot;&#123;&#125;\\n&quot;);&#125;//获取方法Method[] methods = cls.getDeclaredMethods();cls.getMethods();for(int i=0;i&lt;methods.length;i++)&#123; Method cur = methods[i]; sb.append(&quot;\\t&quot;); sb.append(Modifier.toString(cur.getModifiers())+&quot; &quot;+cur.getReturnType().getSimpleName()+&quot; &quot;+cur.getName()); sb.append(&quot;(&quot;); Class[] clss = cur.getParameterTypes(); for(int j=0;j&lt;clss.length;j++)&#123; Class curCls = clss[j]; if(j==clss.length-1)&#123; sb.append(curCls.getSimpleName()); &#125;else&#123; sb.append(curCls.getSimpleName()+&quot;,&quot;); &#125; &#125; sb.append(&quot;)&quot;); sb.append(&quot;&#123;&#125;&quot;); sb.append(&quot;\\n&quot;);&#125;sb.append(&quot;&#125;&quot;);System.out.println(sb);/* 输出： public class Student &#123; public String name; protected String sex; private int id; static boolean flag; Student(String,String)&#123;&#125; public Student(String,String,int)&#123;&#125; public Student()&#123;&#125; private String getName()&#123;&#125; public void setName(String)&#123;&#125; public void printInfo(String)&#123;&#125; private void printInfo()&#123;&#125; &#125;*/ 访问属性(设置获取属性值)获取到一个Field对象之后，我们可以设置、获取对象的这个属性值 1234567891011121314151617&#x2F;&#x2F;传统方式获取设置对象的属性值Student stu1 &#x3D; new Student();stu1.name &#x3D; &quot;张&quot;;System.out.println(stu1.name); &#x2F;&#x2F; 张&#x2F;&#x2F;利用反射机制Class stuCls &#x3D; Class.forName(&quot;Reflection.ClassCollections.Student&quot;);Object stu2 &#x3D; stuCls.newInstance();&#x2F;&#x2F;创建对象Field name &#x3D; stuCls.getDeclaredField(&quot;name&quot;);name.set(stu2, &quot;李四&quot;);System.out.println(name.get(stu2));Field sex &#x3D; stuCls.getDeclaredField(&quot;sex&quot;);sex.setAccessible(true);&#x2F;&#x2F;可以访问非public权限的属性System.out.println(sex.getName());&#x2F;&#x2F; sexsex.set(stu2, &quot;男&quot;); &#x2F;&#x2F; 设置 stu2对象的 sex属性值为“男”System.out.println(sex.get(stu2));&#x2F;&#x2F;获取输出stu2对象的sex属性 若一个属性的访问权限不是public，那么我们设置一个对象的属性值时可能出现异常(没有访问权限)，我们可以调用Field的【setAccessible(true)】来访问该属性 通过反射机制新建对象若对象没有空构造方法，我们就不能用Class对象的newInstance()方法新建对象。这时我们可以获取Class对象的有参构造方法得到Constructor对象，通过Constructor对象的newInstance()方法来新建对象 获取父类信息和实现的接口信息1234567891011121314151617//String 类Class cls = Class.forName(&quot;java.lang.String&quot;);//String 父类Class supCls = cls.getSuperclass();System.out.println(supCls.getSimpleName());//String 实现的接口Class[] interfaces = cls.getInterfaces();for(Class inf:interfaces)&#123; System.out.println(inf.getSimpleName());&#125;/* 输出： Object Serializable Comparable CharSequence*/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"php反序列化字符逃逸","slug":"php反序列化字符逃逸","date":"2020-12-11T04:59:50.000Z","updated":"2020-12-11T12:39:54.557Z","comments":true,"path":"2020/12/11/php反序列化字符逃逸/","link":"","permalink":"http://example.com/2020/12/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/","excerpt":"","text":"PHP序列化与反序列化PHP序列化：serialize序列化是将变量或对象转换成字符串的过程。 例： 12345&lt;?php $_SESSION[&#x27;id&#x27;]=&#x27;001&#x27;; $_SESSION[&#x27;user&#x27;]=&#x27;Ali&#x27;; var_dump(serialize($_SESSION));?&gt; 输出： string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 序列化字符格式： PHP反序列化：unserialize反序列化是将字符串转换成变量或对象的过程。 例： 12345&lt;?php $_SESSION[&#x27;id&#x27;]=&#x27;001&#x27;; $_SESSION[&#x27;user&#x27;]=&#x27;Ali&#x27;; var_dump(unserialize(serialize($_SESSION)));?&gt; 输出： array(2) &#123; [&quot;id&quot;]=&gt; string(3) &quot;001&quot; [&quot;user&quot;]=&gt; string(3) &quot;Ali&quot; &#125; PHP反序列化字符逃逸成因：PHP反序列化时，对序列化格式的严格要求 序列化后的元素都被{}包裹，我们在序列化对象a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;后加入;s:3:&quot;age&quot;;s:2:&quot;12&quot;&#125; 对象依然可以成功被反序列化输出。 例： 12345678910111213&lt;?php $_SESSION[&#x27;id&#x27;]=&#x27;001&#x27;; $_SESSION[&#x27;user&#x27;]=&#x27;Ali&#x27;; $str=serialize($_SESSION); var_dump($str); echo &quot;&lt;br/&gt;&quot;; var_dump(unserialize($str)); echo &quot;&lt;br/&gt;&quot;; $str=$str.&#x27;;s:3:&quot;age&quot;;s:2:&quot;12&quot;&#125;&#x27;; var_dump($str); echo &quot;&lt;br/&gt;&quot;; var_dump(unserialize($str));?&gt; 输出： 1234string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(3) &quot;001&quot; [&quot;user&quot;]&#x3D;&gt; string(3) &quot;Ali&quot; &#125;string(66) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;;s:3:&quot;age&quot;;s:2:&quot;12&quot;&#125;&quot;array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(3) &quot;001&quot; [&quot;user&quot;]&#x3D;&gt; string(3) &quot;Ali&quot; &#125; 若反序列化的对象内部不符合序列化格式，反序列化时则不会正确输出。 例： 12345&lt;?php var_dump(unserialize(&#x27;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&#x27;));//符合序列化格式规范，正确输出 echo &quot;&lt;br/&gt;&quot;; var_dump(unserialize(&#x27;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Alii&quot;;&#125;&#x27;));//user对应的值长度为3，此处为&quot;Alii&quot;长度为4，不会正确输出?&gt; 输出： 12array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(3) &quot;001&quot; [&quot;user&quot;]&#x3D;&gt; string(3) &quot;Ali&quot; &#125;bool(false) 条件：存在字符过滤。 字符过滤分为两种情况：过滤后字符变多或过滤后字符变少。 程序本身的字符过滤和反序列化对格式的严格要求构成了php反序列化字符逃逸。 过滤后字符变多的反序列化字符逃逸例： 1234567891011121314&lt;?php function filter($str)&#123; $filter=&#x27;/1/i&#x27;; return preg_replace($filter,&#x27;11&#x27;,$str); &#125; $_SESSION[&#x27;id&#x27;]=&#x27;001&#x27;; $_SESSION[&#x27;user&#x27;]=&#x27;Ali&#x27;; var_dump(serialize($_SESSION)); echo &quot;&lt;br/&gt;&quot;; var_dump(filter(serialize($_SESSION)));// 输出：// string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;001&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;// string(47) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;0011&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;?&gt; 可以看到我们的字符序列化之后经过过滤值“001”变为”0011”。 若此时我们想要让user的值变为flag。 我们可以尝试让id的值先为：&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125; 序列化输出一下： 1234过滤前：string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 因为id字段值里没有1这个字符，所以过滤前后没有任何变化，让id的值为1&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;输出看一下： 1234过滤前：string(70) &quot;a:2:&#123;s:2:&quot;id&quot;;s:26:&quot;1&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(71) &quot;a:2:&#123;s:2:&quot;id&quot;;s:26:&quot;11&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 可以看到经过过滤之后id值中的最后一个字符&#125;逃逸出来。多输几个1试试：1111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;，输出看一下： 1234过滤前：string(73) &quot;a:2:&#123;s:2:&quot;id&quot;;s:29:&quot;1111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(77) &quot;a:2:&#123;s:2:&quot;id&quot;;s:29:&quot;11111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 可以看到此时id字段值中的后四个字符g&quot;;&#125;逃逸出来，所以要想让&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;都逃逸出来，我们只要在id值前面加入25个1即可。id值：1111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;，输出： 12345过滤前：string(94) &quot;a:2:&#123;s:2:&quot;id&quot;;s:50:&quot;1111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(119) &quot;a:2:&#123;s:2:&quot;id&quot;;s:50:&quot;11111111111111111111111111111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 反序列化一下过滤后的值看看： 12&lt;?phpvar_dump(unserialize(&#x27;a:2:&#123;s:2:&quot;id&quot;;s:50:&quot;11111111111111111111111111111111111111111111111111&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&#x27;)); 输出： 1array(2) &#123; [&quot;id&quot;]&#x3D;&gt; string(50) &quot;11111111111111111111111111111111111111111111111111&quot; [&quot;user&quot;]&#x3D;&gt; string(4) &quot;flag&quot; &#125; 成功将user值变为了flag。 过滤后字符变少的反序列化字符逃逸例： 1234567891011121314&lt;?php function filter($str)&#123; $filter=&#x27;/b/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$str); &#125; $_SESSION[&#x27;id&#x27;]=&#x27;00b&#x27;; $_SESSION[&#x27;user&#x27;]=&#x27;Ali&#x27;; var_dump(serialize($_SESSION)); echo &quot;&lt;br/&gt;&quot;; var_dump(filter(serialize($_SESSION)));// 输出： // string(46) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;00b&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;// string(45) &quot;a:2:&#123;s:2:&quot;id&quot;;s:3:&quot;00&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;?&gt; 可以看到我们的字符序列化之后经过过滤值“00b”变为”00”。 若此时我们想要让user的值变为flag。 我们可以尝试让id的值先为：&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125; 序列化输出： 1234过滤前：string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(69) &quot;a:2:&#123;s:2:&quot;id&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 可以看到id字段值不变，若此时id字段名可控，将id名变为b，输出一下： 1234过滤前：string(68) &quot;a:2:&#123;s:1:&quot;b&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(67) &quot;a:2:&#123;s:1:&quot;&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 可以看到b字段名变成了&quot;向后吞了一位，在吞8位就到我们构造的值那里了，将字段名变为8个b试试：bbbbbbbb，输出看看： 1234过滤前：string(75) &quot;a:2:&#123;s:8:&quot;bbbbbbbb&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(67) &quot;a:2:&#123;s:8:&quot;&quot;;s:25:&quot;&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 我们的字段名经过过滤后变为：&quot;;s:25:&quot;了，所以我们只需要在我们构造的值前面继续构造就可以了。将字段名原先构造的值变为：&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;，输出一下看看： 1234过滤前：string(83) &quot;a:2:&#123;s:8:&quot;bbbbbbbb&quot;;s:33:&quot;&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot;过滤后：string(75) &quot;a:2:&#123;s:8:&quot;&quot;;s:33:&quot;&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&quot; 反序列化输出一下最终构造好的值： 123&lt;?php var_dump(unserialize(&#39;a:2:&#123;s:8:&quot;&quot;;s:33:&quot;&quot;;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;&#125;&quot;;s:4:&quot;user&quot;;s:3:&quot;Ali&quot;;&#125;&#39;));?&gt; 输出： 1array(2) &#123; [&quot;&quot;;s:33:&quot;&quot;]&#x3D;&gt; string(1) &quot;a&quot; [&quot;user&quot;]&#x3D;&gt; string(4) &quot;flag&quot; &#125; 成功修改user的值。","categories":[],"tags":[{"name":"php反序列化","slug":"php反序列化","permalink":"http://example.com/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"软件工程","slug":"软件工程","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"php反序列化","slug":"php反序列化","permalink":"http://example.com/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]}